var documenterSearchIndex = {"docs":
[{"location":"api/misc/#Miscellaneous","page":"Miscellaneous","title":"Miscellaneous","text":"","category":"section"},{"location":"api/misc/","page":"Miscellaneous","title":"Miscellaneous","text":"Other possibly useful functionalities.","category":"page"},{"location":"api/misc/","page":"Miscellaneous","title":"Miscellaneous","text":"Pages = [\"misc.md\"]","category":"page"},{"location":"api/misc/","page":"Miscellaneous","title":"Miscellaneous","text":"Modules = [IntervalLinearAlgebra]\nPages = [\"utils.jl\", \"rref.jl\"]","category":"page"},{"location":"api/misc/#IntervalLinearAlgebra.comparison_matrix-Union{Tuple{StaticArrays.SMatrix{N, N, T, M}}, Tuple{T}, Tuple{M}, Tuple{N}} where {N, M, T<:Interval}","page":"Miscellaneous","title":"IntervalLinearAlgebra.comparison_matrix","text":"comparison_matrix(A::AbstractMatrix{T}) where {T<:Interval}\n\nComputes the comparison matrix A of the given interval matrix A according to the definition Aᵢᵢ = mig(Aᵢᵢ) and Aᵢⱼ = -mag(Aᵢⱼ) if ij.\n\nExamples\n\njulia> A = [2..4 -1..1; -1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> comparison_matrix(A)\n2×2 Matrix{Float64}:\n  2.0  -1.0\n -1.0   2.0\n\n\n\n\n\n","category":"method"},{"location":"api/misc/#IntervalLinearAlgebra.enclose-Union{Tuple{T}, Tuple{N}, Tuple{StaticArrays.StaticMatrix{N, N, T}, StaticArrays.StaticVector{N, T}}} where {N, T<:Interval}","page":"Miscellaneous","title":"IntervalLinearAlgebra.enclose","text":"enclose(A::AbstractMatrix{T}, b::AbstractVector{T}) where {T<:Interval}\n\nComputes an enclosure of the solution of the interval linear system Ax=b using the algorithm described in sec. 5.7.1 of [HOR19].\n\n\n\n\n\n","category":"method"},{"location":"api/misc/#IntervalLinearAlgebra.interval_isapprox-Tuple{Interval, Interval}","page":"Miscellaneous","title":"IntervalLinearAlgebra.interval_isapprox","text":"interval_isapprox(a::Interval, b::Interval; kwargs)\n\nChecks whether the intervals a and b are approximate equal, that is both their lower and upper bound are approximately equal.\n\nKeywords\n\nSame of Base.isapprox\n\nExample\n\njulia> a = 1..2\n[1, 2]\n\njulia> b = a + 1e-10\n[1, 2.00001]\n\njulia> interval_isapprox(a, b)\ntrue\n\njulia> interval_isapprox(a, b; atol=1e-15)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api/misc/#IntervalLinearAlgebra.interval_norm-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Interval","page":"Miscellaneous","title":"IntervalLinearAlgebra.interval_norm","text":"interval_norm(A::AbstractMatrix{T}) where {T<:Interval}\n\ncomputes the infinity norm of interval matrix A.\n\nExamples\n\njulia> A = [2..4 -1..1; -1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> interval_norm(A)\n5.0\n\n\n\n\n\n","category":"method"},{"location":"api/misc/#IntervalLinearAlgebra.interval_norm-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:Interval","page":"Miscellaneous","title":"IntervalLinearAlgebra.interval_norm","text":"interval_norm(A::AbstractVector{T}) where {T<:Interval}\n\ncomputes the infinity norm of interval vector v.\n\nExamples\n\njulia> b = [-2..2, -3..2]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-3, 2]\n\njulia> interval_norm(b)\n3.0\n\n\n\n\n\n","category":"method"},{"location":"api/misc/#IntervalLinearAlgebra.list_orthants-Tuple{Any}","page":"Miscellaneous","title":"IntervalLinearAlgebra.list_orthants","text":"list_orthants(n::Integer)\n\nReturns a list of all the 2ⁿ vectors of length n with elements 1.\n\nExamples\n\njulia> list_orthants(2)\n4-element Vector{Vector{Float64}}:\n [1.0, 1.0]\n [-1.0, 1.0]\n [-1.0, -1.0]\n [1.0, -1.0]\n\n\n\n\n\n","category":"method"},{"location":"api/misc/#IntervalLinearAlgebra.rref!-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Interval","page":"Miscellaneous","title":"IntervalLinearAlgebra.rref!","text":"rref!(A::AbstractMatrix{T}) where {T<:Interval}\n\nIn-place version of rref.\n\n\n\n\n\n","category":"method"},{"location":"api/misc/#IntervalLinearAlgebra.rref-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Interval","page":"Miscellaneous","title":"IntervalLinearAlgebra.rref","text":"rref(A::AbstractMatrix{T}) where {T<:Interval}\n\nComputes the reduced row echelon form of the interval matrix A using maximum mignitude as pivoting strategy.\n\nExamples\n\njulia> A = [2..4 -1..1; -1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> rref(A)\n2×2 Matrix{Interval{Float64}}:\n [2, 4]  [-1, 1]\n [0, 0]       [1.5, 4.5]\n\n\n\n\n\n","category":"method"},{"location":"references/#all_ref","page":"References","title":"References","text":"","category":"section"},{"location":"references/#[HOR19]","page":"References","title":"[HOR19]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"<ul><li>","category":"page"},{"location":"references/","page":"References","title":"References","text":"J. Horácek, Interval Linear and Nonlinear Systems, PhD dissertation, 2019","category":"page"},{"location":"references/","page":"References","title":"References","text":"<li style=\"list-style: none\"><details>\n<summary>bibtex</summary>","category":"page"},{"location":"references/","page":"References","title":"References","text":"@article{horavcek2019interval,\n  title={Interval linear and nonlinear systems},\n  author={Hor{\\'a}{\\v{c}}ek, Jaroslav},\n  year={2019},\n  publisher={Univerzita Karlova, Matematicko-fyzik{\\'a}ln{\\'\\i} fakulta}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"</details></li></ul>","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[JAU14]","page":"References","title":"[JAU14]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"<ul><li>","category":"page"},{"location":"references/","page":"References","title":"References","text":"L. Jaulin and B. Desrochers, Introduction to the algebra of separators with application to path planning, Engineering Applications of Artificial Intelligence 33 (2014): 141-147","category":"page"},{"location":"references/","page":"References","title":"References","text":"<li style=\"list-style: none\"><details>\n<summary>bibtex</summary>","category":"page"},{"location":"references/","page":"References","title":"References","text":"@article{jaulin2014introduction,\n  title={Introduction to the algebra of separators with application to path planning},\n  author={Jaulin, Luc and Desrochers, Beno{\\^\\i}t},\n  journal={Engineering Applications of Artificial Intelligence},\n  volume={33},\n  pages={141--147},\n  year={2014},\n  publisher={Elsevier}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"</details></li></ul>","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[NEU99]","page":"References","title":"[NEU99]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"<ul><li>","category":"page"},{"location":"references/","page":"References","title":"References","text":"A. Neumaier, Interval methods for systems of equations, Cambridge university press, 1990 ","category":"page"},{"location":"references/","page":"References","title":"References","text":"<li style=\"list-style: none\"><details>\n<summary>bibtex</summary>","category":"page"},{"location":"references/","page":"References","title":"References","text":"@book{neumaier1990interval,\n  title={Interval methods for systems of equations},\n  author={Neumaier, Arnold and Neumaier, Arnold},\n  number={37},\n  year={1990},\n  publisher={Cambridge university press}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"</details></li></ul>","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[OET64]","page":"References","title":"[OET64]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"<ul><li>","category":"page"},{"location":"references/","page":"References","title":"References","text":"W. Oettli and W. Prager, Compatibility of approximate solution of linear equa- tions with given error bounds for coefficients and right-hand sides, Numerische Mathematik, 6(1):405–409, 1964.","category":"page"},{"location":"references/","page":"References","title":"References","text":"<li style=\"list-style: none\"><details>\n<summary>bibtex</summary>","category":"page"},{"location":"references/","page":"References","title":"References","text":"@article{oettli1964compatibility,\n  title={Compatibility of approximate solution of linear equations with given error bounds for coefficients and right-hand sides},\n  author={Oettli, Werner and Prager, William},\n  journal={Numerische Mathematik},\n  volume={6},\n  number={1},\n  pages={405--409},\n  year={1964},\n  publisher={Springer}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"</details></li></ul>","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[ROH06]","page":"References","title":"[ROH06]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"<ul><li>","category":"page"},{"location":"references/","page":"References","title":"References","text":"J. Rohn. Solvability of systems of interval linear equations and inequalities, Linear optimization problems with inexact data, pages 35–77. Springer, 2006","category":"page"},{"location":"references/","page":"References","title":"References","text":"<li style=\"list-style: none\"><details>\n<summary>bibtex</summary>","category":"page"},{"location":"references/","page":"References","title":"References","text":"@incollection{rohn2006solvability,\n  title={Solvability of systems of interval linear equations and inequalities},\n  author={Rohn, Jir{\\i}},\n  booktitle={Linear optimization problems with inexact data},\n  pages={35--77},\n  year={2006},\n  publisher={Springer}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"</details></li></ul>","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[RUM10]","page":"References","title":"[RUM10]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"<ul><li>","category":"page"},{"location":"references/","page":"References","title":"References","text":"S.M. Rump, Verification methods: Rigorous results using floating-point arithmetic, Acta Numerica, 19:287–449, 2010","category":"page"},{"location":"references/","page":"References","title":"References","text":"<li style=\"list-style: none\"><details>\n<summary>bibtex</summary>","category":"page"},{"location":"references/","page":"References","title":"References","text":"@article{rump2010verification,\n  title={Verification methods: Rigorous results using floating-point arithmetic},\n  author={Rump, Siegfried M},\n  journal={Acta Numerica},\n  volume={19},\n  pages={287--449},\n  year={2010},\n  publisher={Cambridge University Press}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"</details></li></ul>","category":"page"},{"location":"wip/","page":"Tutorials","title":"Tutorials","text":"still work in progress, stay tuned!","category":"page"},{"location":"api/solve/#General-inteface-for-solving-interval-linear-systems","page":"solver interface","title":"General inteface for solving interval linear systems","text":"","category":"section"},{"location":"api/solve/","page":"solver interface","title":"solver interface","text":"solve","category":"page"},{"location":"api/solve/#CommonSolve.solve","page":"solver interface","title":"CommonSolve.solve","text":"solve(A::AbstractMatrix{T},\n      b::AbstractVector{T},\n      solver::AbstractIterativeSolver,\n      [precondition]::AbstractPrecondition=_default_precondition(A, solver),\n      [X]::AbstractVector{T}=enclose(A, b)) where {T<:Interval}\n\nSolves the square interval system Ax=b using the given algorithm, preconditioner and initial enclosure\n\nInput\n\nA – square interval matrix\nb – interval vector\nsolver – algorithm used to solve the linear system\nprecondition – preconditioner used. If not given, it is automatically computed based on                   the matrix A and the solver.\nX – initial enclosure.        if not given, it is automatically computed using enclose\n\nExamples\n\njulia> A = [2..4 -1..1;-1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> b = [-2..2, -1..1]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-1, 1]\n\njulia> solve(A, b, GaussSeidel(), NoPrecondition(), [-10..10, -10..10])\n2-element Vector{Interval{Float64}}:\n [-1.66668, 1.66668]\n [-1.33334, 1.33334]\n\njulia> solve(A, b, GaussSeidel())\n2-element Vector{Interval{Float64}}:\n [-1.66667, 1.66667]\n [-1.33334, 1.33334]\n\n\n\n\n\nsolve(A::AbstractMatrix{T},\n      b::AbstractVector{T},\n      solver::AbstractDirectSolver,\n      [precondition]::AbstractPrecondition=_default_precondition(A, solver)) where\n      {T<:Interval}\n\nSolves the square interval system Ax=b using the given algorithm, preconditioner and initial enclosure\n\nInput\n\nA – square interval matrix\nb – interval vector\nsolver – algorithm used to solve the linear system\nprecondition – preconditioner used. If not given, it is automatically computed based on                   the matrix A and the solver.\n\nExamples\n\njulia> A = [2..4 -1..1;-1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> b = [-2..2, -1..1]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-1, 1]\n\njulia> solve(A, b, HansenBliekRohn(), InverseMidpoint())\n2-element Vector{Interval{Float64}}:\n [-1.66667, 1.66667]\n [-1.33334, 1.33334]\n\njulia> solve(A, b, HansenBliekRohn())\n2-element Vector{Interval{Float64}}:\n [-1.66667, 1.66667]\n [-1.33334, 1.33334]\n\n\n\n\n\nsolve(A::AbstractMatrix{T},\n      b::AbstractVector{T},\n      [solver]::AbstractLinearSolver,\n      [precondition]::AbstractPrecondition=_default_precondition(A, solver)) where\n      {T<:Interval}\n\nSolves the square interval system Ax=b using the given algorithm, preconditioner and initial enclosure\n\nInput\n\nA – square interval matrix\nb – interval vector\nsolver – algorithm used to solve the linear system. If not given,             GaussianElimination is used.\nprecondition – preconditioner used. If not given, it is automatically computed based on                   the matrix A and the solver.\n\nExamples\n\njulia> A = [2..4 -1..1;-1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> b = [-2..2, -1..1]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-1, 1]\n\njulia> solve(A, b)\n2-element Vector{Interval{Float64}}:\n [-1.66667, 1.66667]\n [-1.33334, 1.33334]\n\n\n\n\n\n","category":"function"},{"location":"api/precondition/#Preconditioners","page":"Preconditioners","title":"Preconditioners","text":"","category":"section"},{"location":"api/precondition/","page":"Preconditioners","title":"Preconditioners","text":"Pages = [\"precondition.md\"]","category":"page"},{"location":"api/precondition/","page":"Preconditioners","title":"Preconditioners","text":"Modules=[IntervalLinearAlgebra]\nPages=[\"precondition.jl\"]\nPrivate=false","category":"page"},{"location":"api/precondition/#IntervalLinearAlgebra.InverseDiagonalMidpoint","page":"Preconditioners","title":"IntervalLinearAlgebra.InverseDiagonalMidpoint","text":"InverseDiagonalMidpoint <: AbstractPrecondition\n\nPreconditioner that preconditions the linear system Ax=b with the diagonal matrix of A_c^-1, where A_c is the midpoint matrix of A.\n\nNotes\n\nAn object of type InverseDiagonalMidpoint is a function with method\n  (idmp::InverseDiagonalMidpoint)(A::AbstractMatrix{T},\n                                  b::AbstractVector{T}) where {T<:Interval}\n\nExample\n\njulia> A = [2..4 -2..1; -1..2 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-2, 1]\n [-1, 2]   [2, 4]\n\njulia> b = [-2..2, -2..2]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-2, 2]\n\njulia> idmp = InverseDiagonalMidpoint()\nInverseDiagonalMidpoint()\n\njulia> idmp(A, b)\n(Interval{Float64}[[0.666666, 1.33334] [-0.666667, 0.333334]; [-0.333334, 0.666667] [0.666666, 1.33334]], Interval{Float64}[[-0.666667, 0.666667], [-0.666667, 0.666667]])\n\n\n\n\n\n","category":"type"},{"location":"api/precondition/#IntervalLinearAlgebra.InverseMidpoint","page":"Preconditioners","title":"IntervalLinearAlgebra.InverseMidpoint","text":"InverseMidpoint <: AbstractPrecondition\n\nPreconditioner that preconditions the linear system Ax=b with A_c^-1, where A_c is the midpoint matrix of A.\n\nNotes\n\nAn object of type InverseMidpoint is a function with method\n  (imp::InverseMidpoint)(A::AbstractMatrix{T},\n                         b::AbstractVector{T}) where {T<:Interval}\n\nExamples\n\njulia> A = [2..4 -2..1; -1..2 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-2, 1]\n [-1, 2]   [2, 4]\n\njulia> b = [-2..2, -2..2]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-2, 2]\n\njulia> imp = InverseMidpoint()\nInverseMidpoint()\n\njulia> imp(A, b)\n(Interval{Float64}[[0.594594, 1.40541] [-0.540541, 0.540541]; [-0.540541, 0.540541] [0.594594, 1.40541]], Interval{Float64}[[-0.756757, 0.756757], [-0.756757, 0.756757]])\n\n\n\n\n\n","category":"type"},{"location":"api/precondition/#IntervalLinearAlgebra.NoPrecondition","page":"Preconditioners","title":"IntervalLinearAlgebra.NoPrecondition","text":"NoPrecondition <: AbstractPrecondition\n\nType of the trivial preconditioner which does nothing.\n\nNotes\n\nAn object of type NoPrecondition is a function with method\n  (np::NoPrecondition)(A::AbstractMatrix{T},\n                       b::AbstractVector{T}) where {T<:Interval}\n\nExample\n\njulia> A = [2..4 -2..1; -1..2 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-2, 1]\n [-1, 2]   [2, 4]\n\njulia> b = [-2..2, -2..2]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-2, 2]\n\njulia> np = NoPrecondition()\nNoPrecondition()\n\njulia> np(A, b)\n(Interval{Float64}[[2, 4] [-2, 1]; [-1, 2] [2, 4]], Interval{Float64}[[-2, 2], [-2, 2]])\n\n\n\n\n\n","category":"type"},{"location":"#IntervalLinearAlgebra.jl","page":"Home","title":"IntervalLinearAlgebra.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: License: MIT) (Image: Build Status) (Image: Coverage) (Image: Dev)","category":"page"},{"location":"","page":"Home","title":"Home","text":"<p align=\"center\">\n    <img src=\"assets/logo.png\" alt=\"IntervalLinearAlgebra.jl\" width=\"450\"/>\n</p>\n\n <p align=\"center\">\n <i>Linear algebra done rigorously</i></p>","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for IntervalLinearAlgebra.jl, a package contains functionalities to solve numerical linear algebra tasks using interval arithmetic.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"note: Note\nThe package is still under active development and everything can change overnight.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Different algorithms to enclose the solution of an interval linear system\nclassify interval matrices\nrigorous solution of real linear systems\nexact characterization of the solution of interval linear systems using Oettli-Präger","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is not registered yet, it can be installed as","category":"page"},{"location":"","page":"Home","title":"Home","text":"(@v1.6) pkg> add https://github.com/lucaferranti/intervallinearalgebra.jl","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using IntervalLinearAlgebra, IntervalConstraintProgramming, Plots\n\nA = [2..4 -1..1;-1..1 2..4]\nb = [-2..2, -1..1]\n\nXenclose = solve(A, b)\nXexact = solve(A, b, NonLinearOettliPrager())\n\nplot(Xexact.inner, ratio=1, label=\"exact\", legend=:top)\nplot!(IntervalBox(Xenclose), label=\"enclosure\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: quickstart-example)","category":"page"},{"location":"api/algorithms/#Algorithms","page":"Algorithms","title":"Algorithms","text":"","category":"section"},{"location":"api/algorithms/","page":"Algorithms","title":"Algorithms","text":"Algorithms used to solve interval linear systems.","category":"page"},{"location":"api/algorithms/","page":"Algorithms","title":"Algorithms","text":"Pages=[\"classify.md\"]","category":"page"},{"location":"api/algorithms/#Enclosure-computation","page":"Algorithms","title":"Enclosure computation","text":"","category":"section"},{"location":"api/algorithms/#Direct-methods","page":"Algorithms","title":"Direct methods","text":"","category":"section"},{"location":"api/algorithms/","page":"Algorithms","title":"Algorithms","text":"GaussianElimination\nHansenBliekRohn","category":"page"},{"location":"api/algorithms/#IntervalLinearAlgebra.GaussianElimination","page":"Algorithms","title":"IntervalLinearAlgebra.GaussianElimination","text":"GaussianElimination <: AbstractDirectSolver\n\nType for the Gaussian elimination solver of the square interval linear system Ax=b. For more details see section 5.6.1 of [HOR19]\n\nNotes\n\nAn object of type GaussianElimination is a callable function with method\n  (ge::GaussianElimination)(A::AbstractMatrix{T},\n                            b::AbstractVector{T}) where {T<:Interval}\n\nExamples\n\njulia> A = [2..4 -1..1;-1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> b = [-2..2, -1..1]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-1, 1]\n\njulia> ge = GaussianElimination()\nGaussianElimination linear solver\n\njulia> ge(A, b)\n2-element Vector{Interval{Float64}}:\n [-1.66667, 1.66667]\n [-1.33334, 1.33334]\n\n\n\n\n\n","category":"type"},{"location":"api/algorithms/#IntervalLinearAlgebra.HansenBliekRohn","page":"Algorithms","title":"IntervalLinearAlgebra.HansenBliekRohn","text":"HansenBliekRohn <: AbstractDirectSolver\n\nType for the HansenBliekRohn solver of the square interval linear system Ax=b. For more details see section 5.6.2 of [HOR19]\n\nNotes\n\nHansen-Bliek-Rohn works with H-matrices without precondition and with strongly regular matrices using InverseMidpoint precondition\nIf the midpoint of A is a diagonal matrix, then the algorithm returns the exact hull.\nAn object of type Hansen-Bliek-Rohn is a callable function with method\n  (hbr::HansenBliekRohn)(A::AbstractMatrix{T},\n                         b::AbstractVector{T}) where {T<:Interval}\n\nExamples\n\njulia> A = [2..4 -1..1;-1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> b = [-2..2, -1..1]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-1, 1]\n\njulia> hbr = HansenBliekRohn()\nHansenBliekRohn linear solver\n\njulia> hbr(A, b)\n2-element Vector{Interval{Float64}}:\n [-1.66667, 1.66667]\n [-1.33334, 1.33334]\n\n\n\n\n\n","category":"type"},{"location":"api/algorithms/#Iterative-methods","page":"Algorithms","title":"Iterative methods","text":"","category":"section"},{"location":"api/algorithms/","page":"Algorithms","title":"Algorithms","text":"GaussSeidel\nJacobi\nLinearKrawczyk","category":"page"},{"location":"api/algorithms/#IntervalLinearAlgebra.GaussSeidel","page":"Algorithms","title":"IntervalLinearAlgebra.GaussSeidel","text":"GaussSeidel <: AbstractIterativeSolver\n\nType for the Gauss-Seidel solver of the interval linear system Ax=b. For details see Section 5.7.4 of [HOR19]\n\nFields\n\nmax_iterations – maximum number of iterations (default 20)\natol           – absolute tolerance (default 0), if at some point xₖ - xₖ₁  atol                     (elementwise), then stop and return xₖ₁.                     If atol=0, then min(diam(A))*1e-5 is used.\n\nNotes\n\nAn object of type GaussSeidel is a function with method\n  (gs::GaussSeidel)(A::AbstractMatrix{T},\n                    b::AbstractVector{T},\n                    [x]::AbstractVector{T}=enclose(A, b)) where {T<:Interval}\nInput\nA   – N×N interval matrix\nb   – interval vector of length N\nx   – (optional) initial enclosure for the solution of Ax = b. If not given,          it is automatically computed using enclose\n\nExamples\n\njulia> A = [2..4 -1..1;-1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> b = [-2..2, -1..1]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-1, 1]\n\njulia> gs = GaussSeidel()\nGaussSeidel linear solver\nmax_iterations = 20\natol = 0.0\n\njulia> gs(A, b)\n2-element Vector{Interval{Float64}}:\n [-1.66668, 1.66668]\n [-1.33334, 1.33334]\n\n\n\n\n\n","category":"type"},{"location":"api/algorithms/#IntervalLinearAlgebra.Jacobi","page":"Algorithms","title":"IntervalLinearAlgebra.Jacobi","text":"Jacobi <: AbstractIterativeSolver\n\nType for the Jacobi solver of the interval linear system Ax=b. For details see Section 5.7.4 of [HOR19]\n\nFields\n\nmax_iterations – maximum number of iterations (default 20)\natol           – absolute tolerance (default 0), if at some point xₖ - xₖ₁  atol                     (elementwise), then stop and return xₖ₁.                     If atol=0, then min(diam(A))*1e-5 is used.\n\nNotes\n\nAn object of type Jacobi is a function with method\n  (jac::Jacobi)(A::AbstractMatrix{T},\n                b::AbstractVector{T},\n                [x]::AbstractVector{T}=enclose(A, b)) where {T<:Interval}\nInput\nA   – N×N interval matrix\nb   – interval vector of length N\nx   – (optional) initial enclosure for the solution of Ax = b. If not given,          it is automatically computed using enclose\n\nExamples\n\njulia> A = [2..4 -1..1;-1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> b = [-2..2, -1..1]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-1, 1]\n\njulia> jac = Jacobi()\nJacobi linear solver\nmax_iterations = 20\natol = 0.0\n\njulia> jac(A, b)\n2-element Vector{Interval{Float64}}:\n [-1.66668, 1.66668]\n [-1.33335, 1.33335]\n\n\n\n\n\n","category":"type"},{"location":"api/algorithms/#IntervalLinearAlgebra.LinearKrawczyk","page":"Algorithms","title":"IntervalLinearAlgebra.LinearKrawczyk","text":"LinearKrawczyk <: AbstractIterativeSolver\n\nType for the Krawczyk solver of the interval linear system Ax=b. For details see Section 5.7.3 of [HOR19]\n\nFields\n\nmax_iterations – maximum number of iterations (default 20)\natol           – absolute tolerance (default 0), if at some point xₖ - xₖ₁  atol                     (elementwise), then stop and return xₖ₁.                     If atol=0, then min(diam(A))*1e-5 is used.\n\nNotes\n\nAn object of type LinearKrawczyk is a function with method\n  (kra::LinearKrawczyk)(A::AbstractMatrix{T},\n                        b::AbstractVector{T},\n                        [x]::AbstractVector{T}=enclose(A, b)) where {T<:Interval}\nInput\nA   – N×N interval matrix\nb   – interval vector of length N\nx   – (optional) initial enclosure for the solution of Ax = b. If not given,          it is automatically computed using enclose\n\nExamples\n\njulia> A = [2..4 -1..1;-1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> b = [-2..2, -1..1]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-1, 1]\n\njulia> kra = LinearKrawczyk()\nLinearKrawczyk linear solver\nmax_iterations = 20\natol = 0.0\n\njulia> kra(A, b)\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-2, 2]\n\n\n\n\n\n","category":"type"},{"location":"api/algorithms/#Exact-characterization","page":"Algorithms","title":"Exact characterization","text":"","category":"section"},{"location":"api/algorithms/","page":"Algorithms","title":"Algorithms","text":"NonLinearOettliPrager","category":"page"},{"location":"api/algorithms/#IntervalLinearAlgebra.NonLinearOettliPrager","page":"Algorithms","title":"IntervalLinearAlgebra.NonLinearOettliPrager","text":"NonLinearOettliPrager <: AbstractIterativeSolver\n\nType for the OettliPrager solver of the interval linear system Ax=b. The solver first converts the system of interval equalities into a system of real inequalities using Oettli-Präger theorem [OET64] and then finds the feasible set using the forward-backward contractor method [JAU14] implemented in IntervalConstraintProgramming.jl.\n\nFields\n\ntol – tolerance for the paving, default 0.01.\n\nNotes\n\nYou need to import IntervalConstraintProgramming.jl to use this functionality.\nAn object of type OettliPrager is a function with methods\n  (op::OettliPrager)(A::AbstractMatrix{T},\n                     b::AbstractVector{T},\n                     [X]::AbstractVector{T}=enclose(A, b)) where {T<:Interval}\n\n  (op::OettliPrager)(A::AbstractMatrix{T},\n                     b::AbstractVector{T},\n                     X::IntervalBox) where {T<:Interval}\nInput\nA   – N×N interval matrix\nb   – interval vector of length N\nX   – (optional) initial enclosure for the solution of Ax = b. If not given,          it is automatically computed using enclose\n\nExamples\n\njulia> A = [2..4 -2..1;-1..2 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-2, 1]\n [-1, 2]   [2, 4]\n\njulia> b = [-2..2, -2..2]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-2, 2]\n\njulia> op = NonLinearOettliPrager(0.1)\nNonLinearOettliPrager linear solver\ntol = 0.1\n\njulia> op(A, b)\nPaving:\n- tolerance ϵ = 0.1\n- inner approx. of length 1195\n- boundary approx. of length 823\n\n\n\n\n\n","category":"type"},{"location":"api/classify/#Interval-matrices-classification","page":"Interval matrices classification","title":"Interval matrices classification","text":"","category":"section"},{"location":"api/classify/","page":"Interval matrices classification","title":"Interval matrices classification","text":"Pages = [\"classify.md\"]","category":"page"},{"location":"api/classify/","page":"Interval matrices classification","title":"Interval matrices classification","text":"Modules=[IntervalLinearAlgebra]\nPages = [\"classify.jl\"]","category":"page"},{"location":"api/classify/#IntervalLinearAlgebra.is_H_matrix-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Interval","page":"Interval matrices classification","title":"IntervalLinearAlgebra.is_H_matrix","text":"is_H_matrix(A::AbstractMatrix{T}) where {T<:Interval}\n\nTests whether the square interval matrix A is an H-matrix, by testing that A^-1e0, where e=1 1  1ᵀ. Note that in practice it tests that a floating point approximation of A^-1e satisfies the condition. For more details see section 4.4 of [HOR19].\n\nExamples\n\njulia> A = [2..4 -1..1; -1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> is_H_matrix(A)\ntrue\n\njulia> A = [2..4 -2..1; -1..2 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-2, 1]\n [-1, 2]   [2, 4]\n\njulia> is_H_matrix(A)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api/classify/#IntervalLinearAlgebra.is_M_matrix-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Interval","page":"Interval matrices classification","title":"IntervalLinearAlgebra.is_M_matrix","text":"is_M_matrix(A::AbstractMatrix{T}) where {T<:Interval}\n\nChecks whether the square interval matrix A is an M-matrix, that is a Z-matrix with non-negative inverse. For more details see section 4.2 of [HOR19].\n\nExamples\n\njulia> A = [2..2 -1..0; -1..0 2..2]\n2×2 Matrix{Interval{Float64}}:\n  [2, 2]  [-1, 0]\n [-1, 0]   [2, 2]\n\njulia> is_M_matrix(A)\ntrue\n\njulia> A = [2..4 -2..1; -1..2 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-2, 1]\n [-1, 2]   [2, 4]\n\njulia> is_M_matrix(A)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api/classify/#IntervalLinearAlgebra.is_Z_matrix-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Interval","page":"Interval matrices classification","title":"IntervalLinearAlgebra.is_Z_matrix","text":"is_Z_matrix(A::AbstractMatrix{T}) where {T<:Interval}\n\nChecks whether the square interval matrix A is a Z-matrix, that is whether Aᵢⱼ0 for all ij. For more details see section 4.2 of [HOR19].\n\nExamples\n\njulia> A = [2..4 -2.. -1; -2.. -1 2..4]\n2×2 Matrix{Interval{Float64}}:\n   [2, 4]  [-2, -1]\n [-2, -1]    [2, 4]\n\njulia> is_Z_matrix(A)\ntrue\n\njulia> A = [2..4 -2..1; -1..2 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-2, 1]\n [-1, 2]   [2, 4]\n\njulia> is_Z_matrix(A)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api/classify/#IntervalLinearAlgebra.is_strictly_diagonally_dominant-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Interval","page":"Interval matrices classification","title":"IntervalLinearAlgebra.is_strictly_diagonally_dominant","text":"is_strictly_diagonally_dominant(A::AbstractMatrix{T}) where {T<:Interval}\n\nChecks whether the square interval matrix A of order n is stictly diagonally dominant, that is if mig(Aᵢᵢ)  _k  i mag(Aᵢₖ) for i=1n. For more details see section 4.5 of [HOR19].\n\nExamples\n\njulia> A = [2..4 -1..1; -1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> is_strictly_diagonally_dominant(A)\ntrue\n\njulia> A = [2..4 -2..1; -1..2 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-2, 1]\n [-1, 2]   [2, 4]\n\njulia> is_strictly_diagonally_dominant(A)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api/classify/#IntervalLinearAlgebra.is_strongly_regular-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Interval","page":"Interval matrices classification","title":"IntervalLinearAlgebra.is_strongly_regular","text":"is_strongly_regular(A::AbstractMatrix{T}) where {T<:Interval}\n\nTests whether the square interval matrix A is strongly regular, i.e. if A_c^-1A is an H-matrix, where A_c is the midpoint matrix of A`. For more details see section 4.6 of [HOR19].\n\nExamples\n\njulia> A = [2..4 -2..1; -1..2 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-2, 1]\n [-1, 2]   [2, 4]\n\njulia> is_strongly_regular(A)\ntrue\n\njulia> A = [0..2 1..1;-1.. -1 0..2]\n2×2 Matrix{Interval{Float64}}:\n   [0, 2]  [1, 1]\n [-1, -1]  [0, 2]\n\njulia> is_strongly_regular(A)\nfalse\n\n\n\n\n\n","category":"method"}]
}
