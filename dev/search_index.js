var documenterSearchIndex = {"docs":
[{"location":"references/#all_ref","page":"References","title":"References","text":"","category":"section"},{"location":"references/#[HOR19]","page":"References","title":"[HOR19]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"<ul><li>","category":"page"},{"location":"references/","page":"References","title":"References","text":"J. Horácek, Interval Linear and Nonlinear Systems, PhD dissertation, 2019","category":"page"},{"location":"references/","page":"References","title":"References","text":"<li style=\"list-style: none\"><details>\n<summary>bibtex</summary>","category":"page"},{"location":"references/","page":"References","title":"References","text":"@article{horavcek2019interval,\n  title={Interval linear and nonlinear systems},\n  author={Hor{\\'a}{\\v{c}}ek, Jaroslav},\n  year={2019},\n  publisher={Univerzita Karlova, Matematicko-fyzik{\\'a}ln{\\'\\i} fakulta}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"</details></li></ul>","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[JAU14]","page":"References","title":"[JAU14]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"<ul><li>","category":"page"},{"location":"references/","page":"References","title":"References","text":"L. Jaulin and B. Desrochers, Introduction to the algebra of separators with application to path planning, Engineering Applications of Artificial Intelligence 33 (2014): 141-147","category":"page"},{"location":"references/","page":"References","title":"References","text":"<li style=\"list-style: none\"><details>\n<summary>bibtex</summary>","category":"page"},{"location":"references/","page":"References","title":"References","text":"@article{jaulin2014introduction,\n  title={Introduction to the algebra of separators with application to path planning},\n  author={Jaulin, Luc and Desrochers, Beno{\\^\\i}t},\n  journal={Engineering Applications of Artificial Intelligence},\n  volume={33},\n  pages={141--147},\n  year={2014},\n  publisher={Elsevier}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"</details></li></ul>","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[NEU99]","page":"References","title":"[NEU99]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"<ul><li>","category":"page"},{"location":"references/","page":"References","title":"References","text":"A. Neumaier, Interval methods for systems of equations, Cambridge university press, 1990 ","category":"page"},{"location":"references/","page":"References","title":"References","text":"<li style=\"list-style: none\"><details>\n<summary>bibtex</summary>","category":"page"},{"location":"references/","page":"References","title":"References","text":"@book{neumaier1990interval,\n  title={Interval methods for systems of equations},\n  author={Neumaier, Arnold and Neumaier, Arnold},\n  number={37},\n  year={1990},\n  publisher={Cambridge university press}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"</details></li></ul>","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[OET64]","page":"References","title":"[OET64]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"<ul><li>","category":"page"},{"location":"references/","page":"References","title":"References","text":"W. Oettli and W. Prager, Compatibility of approximate solution of linear equa- tions with given error bounds for coefficients and right-hand sides, Numerische Mathematik, 6(1):405–409, 1964.","category":"page"},{"location":"references/","page":"References","title":"References","text":"<li style=\"list-style: none\"><details>\n<summary>bibtex</summary>","category":"page"},{"location":"references/","page":"References","title":"References","text":"@article{oettli1964compatibility,\n  title={Compatibility of approximate solution of linear equations with given error bounds for coefficients and right-hand sides},\n  author={Oettli, Werner and Prager, William},\n  journal={Numerische Mathematik},\n  volume={6},\n  number={1},\n  pages={405--409},\n  year={1964},\n  publisher={Springer}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"</details></li></ul>","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[ROH06]","page":"References","title":"[ROH06]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"<ul><li>","category":"page"},{"location":"references/","page":"References","title":"References","text":"J. Rohn. Solvability of systems of interval linear equations and inequalities, Linear optimization problems with inexact data, pages 35–77. Springer, 2006","category":"page"},{"location":"references/","page":"References","title":"References","text":"<li style=\"list-style: none\"><details>\n<summary>bibtex</summary>","category":"page"},{"location":"references/","page":"References","title":"References","text":"@incollection{rohn2006solvability,\n  title={Solvability of systems of interval linear equations and inequalities},\n  author={Rohn, Jir{\\i}},\n  booktitle={Linear optimization problems with inexact data},\n  pages={35--77},\n  year={2006},\n  publisher={Springer}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"</details></li></ul>","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[RUM10]","page":"References","title":"[RUM10]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"<ul><li>","category":"page"},{"location":"references/","page":"References","title":"References","text":"S.M. Rump, Verification methods: Rigorous results using floating-point arithmetic, Acta Numerica, 19:287–449, 2010","category":"page"},{"location":"references/","page":"References","title":"References","text":"<li style=\"list-style: none\"><details>\n<summary>bibtex</summary>","category":"page"},{"location":"references/","page":"References","title":"References","text":"@article{rump2010verification,\n  title={Verification methods: Rigorous results using floating-point arithmetic},\n  author={Rump, Siegfried M},\n  journal={Acta Numerica},\n  volume={19},\n  pages={287--449},\n  year={2010},\n  publisher={Cambridge University Press}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"</details></li></ul>","category":"page"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = IntervalLinearAlgebra","category":"page"},{"location":"api/#IntervalLinearAlgebra","page":"API","title":"IntervalLinearAlgebra","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Documentation for IntervalLinearAlgebra.","category":"page"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [IntervalLinearAlgebra]","category":"page"},{"location":"api/#IntervalLinearAlgebra.AbstractDirectSolver","page":"API","title":"IntervalLinearAlgebra.AbstractDirectSolver","text":"AbstractDirectSolver <: AbstractLinearSolver\n\nAbstract type for direct solvers of interval linear systems, such as Gaussian elimination and Hansen-Bliek-Rohn.\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalLinearAlgebra.AbstractIterativeSolver","page":"API","title":"IntervalLinearAlgebra.AbstractIterativeSolver","text":"AbstractIterativeSolver <: AbstractLinearSolver\n\nAbstract type for iterative solvers of interval linear systems, such as Jacobi or Gauss-Seidel.\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalLinearAlgebra.AbstractLinearSolver","page":"API","title":"IntervalLinearAlgebra.AbstractLinearSolver","text":"AbstractLinearSolver\n\nAbstract type for solvers of interval linear systems.\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalLinearAlgebra.AbstractPrecondition","page":"API","title":"IntervalLinearAlgebra.AbstractPrecondition","text":"AbstractPrecondition\n\nAbstract type for preconditioners of interval linear systems.\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalLinearAlgebra.GaussSeidel","page":"API","title":"IntervalLinearAlgebra.GaussSeidel","text":"GaussSeidel <: AbstractIterativeSolver\n\nType for the Gauss-Seidel solver of the interval linear system Ax=b. For details see Section 5.7.4 of [HOR19]\n\nFields\n\nmax_iterations – maximum number of iterations (default 20)\natol           – absolute tolerance (default 0), if at some point xₖ - xₖ₁  atol                     (elementwise), then stop and return xₖ₁.                     If atol=0, then min(diam(A))*1e-5 is used.\n\nNotes\n\nAn object of type GaussSeidel is a function with method\n  (gs::GaussSeidel)(A::AbstractMatrix{T},\n                    b::AbstractVector{T},\n                    [x]::AbstractVector{T}=enclose(A, b)) where {T<:Interval}\nInput\nA   – N×N interval matrix\nb   – interval vector of length N\nx   – (optional) initial enclosure for the solution of Ax = b. If not given,          it is automatically computed using enclose\n\nExamples\n\njulia> A = [2..4 -1..1;-1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> b = [-2..2, -1..1]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-1, 1]\n\njulia> gs = GaussSeidel()\nGaussSeidel linear solver\nmax_iterations = 20\natol = 0.0\n\njulia> gs(A, b)\n2-element Vector{Interval{Float64}}:\n [-1.66668, 1.66668]\n [-1.33334, 1.33334]\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalLinearAlgebra.GaussianElimination","page":"API","title":"IntervalLinearAlgebra.GaussianElimination","text":"GaussianElimination <: AbstractDirectSolver\n\nType for the Gaussian elimination solver of the square interval linear system Ax=b. For more details see section 5.6.1 of [HOR19]\n\nNotes\n\nAn object of type GaussianElimination is a callable function with method\n  (ge::GaussianElimination)(A::AbstractMatrix{T},\n                            b::AbstractVector{T}) where {T<:Interval}\n\nExamples\n\njulia> A = [2..4 -1..1;-1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> b = [-2..2, -1..1]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-1, 1]\n\njulia> ge = GaussianElimination()\nGaussianElimination linear solver\n\njulia> ge(A, b)\n2-element Vector{Interval{Float64}}:\n [-1.66667, 1.66667]\n [-1.33334, 1.33334]\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalLinearAlgebra.HansenBliekRohn","page":"API","title":"IntervalLinearAlgebra.HansenBliekRohn","text":"HansenBliekRohn <: AbstractDirectSolver\n\nType for the HansenBliekRohn solver of the square interval linear system Ax=b. For more details see section 5.6.2 of [HOR19]\n\nNotes\n\nHansen-Bliek-Rohn works with H-matrices without precondition and with strongly regular matrices using InverseMidpoint precondition\nIf the midpoint of A is a diagonal matrix, then the algorithm returns the exact hull.\nAn object of type Hansen-Bliek-Rohn is a callable function with method\n  (hbr::HansenBliekRohn)(A::AbstractMatrix{T},\n                         b::AbstractVector{T}) where {T<:Interval}\n\nExamples\n\njulia> A = [2..4 -1..1;-1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> b = [-2..2, -1..1]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-1, 1]\n\njulia> hbr = HansenBliekRohn()\nHansenBliekRohn linear solver\n\njulia> hbr(A, b)\n2-element Vector{Interval{Float64}}:\n [-1.66667, 1.66667]\n [-1.33334, 1.33334]\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalLinearAlgebra.InverseDiagonalMidpoint","page":"API","title":"IntervalLinearAlgebra.InverseDiagonalMidpoint","text":"InverseDiagonalMidpoint <: Precondition\n\nPreconditioner that preconditions the linear system Ax=b with the diagonal matrix of A_c^-1, where A_c is the midpoint matrix of A.\n\nNotes\n\nAn object of type InverseDiagonalMidpoint is a function with method\n  (idmp::InverseDiagonalMidpoint)(A::AbstractMatrix{T},\n                                  b::AbstractVector{T}) where {T<:Interval}\n\nExample\n\njulia> A = [2..4 -2..1; -1..2 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-2, 1]\n [-1, 2]   [2, 4]\n\njulia> b = [-2..2, -2..2]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-2, 2]\n\njulia> idmp = InverseDiagonalMidpoint()\nInverseDiagonalMidpoint()\n\njulia> idmp(A, b)\n(Interval{Float64}[[0.666666, 1.33334] [-0.666667, 0.333334]; [-0.333334, 0.666667] [0.666666, 1.33334]], Interval{Float64}[[-0.666667, 0.666667], [-0.666667, 0.666667]])\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalLinearAlgebra.InverseMidpoint","page":"API","title":"IntervalLinearAlgebra.InverseMidpoint","text":"InverseMidpoint <: Precondition\n\nPreconditioner that preconditions the linear system Ax=b with A_c^-1, where A_c is the midpoint matrix of A.\n\nNotes\n\nAn object of type NoPrecondition is a function with method\n  (imp::InverseMidpoint)(A::AbstractMatrix{T},\n                         b::AbstractVector{T}) where {T<:Interval}\n\nExamples\n\njulia> A = [2..4 -2..1; -1..2 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-2, 1]\n [-1, 2]   [2, 4]\n\njulia> b = [-2..2, -2..2]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-2, 2]\n\njulia> imp = InverseMidpoint()\nInverseMidpoint()\n\njulia> imp(A, b)\n(Interval{Float64}[[0.594594, 1.40541] [-0.540541, 0.540541]; [-0.540541, 0.540541] [0.594594, 1.40541]], Interval{Float64}[[-0.756757, 0.756757], [-0.756757, 0.756757]])\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalLinearAlgebra.Jacobi","page":"API","title":"IntervalLinearAlgebra.Jacobi","text":"Jacobi <: AbstractIterativeSolver\n\nType for the Jacobi solver of the interval linear system Ax=b. For details see Section 5.7.4 of [HOR19]\n\nFields\n\nmax_iterations – maximum number of iterations (default 20)\natol           – absolute tolerance (default 0), if at some point xₖ - xₖ₁  atol                     (elementwise), then stop and return xₖ₁.                     If atol=0, then min(diam(A))*1e-5 is used.\n\nNotes\n\nAn object of type Jacobi is a function with method\n  (jac::Jacobi)(A::AbstractMatrix{T},\n                b::AbstractVector{T},\n                [x]::AbstractVector{T}=enclose(A, b)) where {T<:Interval}\nInput\nA   – N×N interval matrix\nb   – interval vector of length N\nx   – (optional) initial enclosure for the solution of Ax = b. If not given,          it is automatically computed using enclose\n\nExamples\n\njulia> A = [2..4 -1..1;-1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> b = [-2..2, -1..1]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-1, 1]\n\njulia> jac = Jacobi()\nJacobi linear solver\nmax_iterations = 20\natol = 0.0\n\njulia> jac(A, b)\n2-element Vector{Interval{Float64}}:\n [-1.66668, 1.66668]\n [-1.33335, 1.33335]\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalLinearAlgebra.LinearKrawczyk","page":"API","title":"IntervalLinearAlgebra.LinearKrawczyk","text":"LinearKrawczyk <: AbstractIterativeSolver\n\nType for the Krawczyk solver of the interval linear system Ax=b. For details see Section 5.7.3 of [HOR19]\n\nFields\n\nmax_iterations – maximum number of iterations (default 20)\natol           – absolute tolerance (default 0), if at some point xₖ - xₖ₁  atol                     (elementwise), then stop and return xₖ₁.                     If atol=0, then min(diam(A))*1e-5 is used.\n\nNotes\n\nAn object of type LinearKrawczyk is a function with method\n  (kra::LinearKrawczyk)(A::AbstractMatrix{T},\n                        b::AbstractVector{T},\n                        [x]::AbstractVector{T}=enclose(A, b)) where {T<:Interval}\nInput\nA   – N×N interval matrix\nb   – interval vector of length N\nx   – (optional) initial enclosure for the solution of Ax = b. If not given,          it is automatically computed using enclose\n\nExamples\n\njulia> A = [2..4 -1..1;-1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> b = [-2..2, -1..1]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-1, 1]\n\njulia> kra = LinearKrawczyk()\nLinearKrawczyk linear solver\nmax_iterations = 20\natol = 0.0\n\njulia> kra(A, b)\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-2, 2]\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalLinearAlgebra.NoPrecondition","page":"API","title":"IntervalLinearAlgebra.NoPrecondition","text":"NoPrecondition <: AbstractPrecondition\n\nType of the trivial preconditioner which does nothing.\n\nNotes\n\nAn object of type NoPrecondition is a function with method\n  (np::NoPrecondition)(A::AbstractMatrix{T},\n                       b::AbstractVector{T}) where {T<:Interval}\n\nExample\n\njulia> A = [2..4 -2..1; -1..2 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-2, 1]\n [-1, 2]   [2, 4]\n\njulia> b = [-2..2, -2..2]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-2, 2]\n\njulia> np = NoPrecondition()\nNoPrecondition()\n\njulia> np(A, b)\n(Interval{Float64}[[2, 4] [-2, 1]; [-1, 2] [2, 4]], Interval{Float64}[[-2, 2], [-2, 2]])\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalLinearAlgebra.NonLinearOettliPrager","page":"API","title":"IntervalLinearAlgebra.NonLinearOettliPrager","text":"NonLinearOettliPrager <: AbstractLinearSolver\n\nType for the OettliPrager solver of the interval linear system Ax=b. The solver first converts the system of interval equalities into a system of real inequalities using Oettli-Präger theorem [OET64] and then finds the feasible set using the forward-backward contractor method [JAU14] implemented in IntervalConstraintProgramming.jl.\n\nFields\n\ntol – tolerance for the paving, default 0.01.\n\nNotes\n\nYou need to import IntervalConstraintProgramming.jl to use this functionality.\nAn object of type OettliPrager is a function with methods\n  (op::OettliPrager)(A::AbstractMatrix{T},\n                     b::AbstractVector{T},\n                     [X]::AbstractVector{T}=enclose(A, b)) where {T<:Interval}\n\n  (op::OettliPrager)(A::AbstractMatrix{T},\n                     b::AbstractVector{T},\n                     X::IntervalBox) where {T<:Interval}\nInput\nA   – N×N interval matrix\nb   – interval vector of length N\nX   – (optional) initial enclosure for the solution of Ax = b. If not given,          it is automatically computed using enclose\n\nExamples\n\njulia> A = [2..4 -2..1;-1..2 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-2, 1]\n [-1, 2]   [2, 4]\n\njulia> b = [-2..2, -2..2]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-2, 2]\n\njulia> op = NonLinearOettliPrager(0.1)\nNonLinearOettliPrager linear solver\ntol = 0.1\n\njulia> op(A, b)\nPaving:\n- tolerance ϵ = 0.1\n- inner approx. of length 1195\n- boundary approx. of length 823\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalLinearAlgebra.comparison_matrix-Union{Tuple{StaticArrays.SMatrix{N, N, T, M}}, Tuple{T}, Tuple{M}, Tuple{N}} where {N, M, T<:Interval}","page":"API","title":"IntervalLinearAlgebra.comparison_matrix","text":"comparison_matrix(A::AbstractMatrix{T}) where {T<:Interval}\n\nComputes the comparison matrix A of the given interval matrix A according to the definition Aᵢᵢ = mig(Aᵢᵢ) and Aᵢⱼ = -mag(Aᵢⱼ) if ij.\n\nExamples\n\njulia> A = [2..4 -1..1; -1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> comparison_matrix(A)\n2×2 Matrix{Float64}:\n  2.0  -1.0\n -1.0   2.0\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalLinearAlgebra.enclose-Union{Tuple{T}, Tuple{N}, Tuple{StaticArrays.StaticMatrix{N, N, T}, StaticArrays.StaticVector{N, T}}} where {N, T<:Interval}","page":"API","title":"IntervalLinearAlgebra.enclose","text":"enclose(A::AbstractMatrix{T}, b::AbstractVector{T}) where {T<:Interval}\n\nComputes an enclosure of the solution of the interval linear system Ax=b using the algorithm described in sec. 5.7.1 of [HOR19].\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalLinearAlgebra.interval_isapprox-Tuple{Interval, Interval}","page":"API","title":"IntervalLinearAlgebra.interval_isapprox","text":"interval_isapprox(a::Interval, b::Interval; kwargs)\n\nChecks whether the intervals a and b are approximate equal, that is both their lower and upper bound are approximately equal.\n\nKeywords\n\nSame of Base.isapprox\n\nExample\n\njulia> a = 1..2\n[1, 2]\n\njulia> b = a + 1e-10\n[1, 2.00001]\n\njulia> interval_isapprox(a, b)\ntrue\n\njulia> interval_isapprox(a, b; atol=1e-15)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalLinearAlgebra.interval_norm-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Interval","page":"API","title":"IntervalLinearAlgebra.interval_norm","text":"interval_norm(A::AbstractMatrix{T}) where {T<:Interval}\n\ncomputes the infinity norm of interval matrix A.\n\nExamples\n\njulia> A = [2..4 -1..1; -1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> interval_norm(A)\n5.0\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalLinearAlgebra.interval_norm-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:Interval","page":"API","title":"IntervalLinearAlgebra.interval_norm","text":"interval_norm(A::AbstractVector{T}) where {T<:Interval}\n\ncomputes the infinity norm of interval vector v.\n\nExamples\n\njulia> b = [-2..2, -3..2]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-3, 2]\n\njulia> interval_norm(b)\n3.0\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalLinearAlgebra.is_H_matrix-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Interval","page":"API","title":"IntervalLinearAlgebra.is_H_matrix","text":"is_H_matrix(A::AbstractMatrix{T}) where {T<:Interval}\n\nTests whether the square interval matrix A is an H-matrix, by testing that A^-1e0, where e=1 1  1ᵀ. Note that in practice it tests that a floating point approximation of A^-1e satisfies the condition. For more details see section 4.4 of [HOR19].\n\nExamples\n\njulia> A = [2..4 -1..1; -1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> is_H_matrix(A)\ntrue\n\njulia> A = [2..4 -2..1; -1..2 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-2, 1]\n [-1, 2]   [2, 4]\n\njulia> is_H_matrix(A)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalLinearAlgebra.is_M_matrix-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Interval","page":"API","title":"IntervalLinearAlgebra.is_M_matrix","text":"is_M_matrix(A::AbstractMatrix{T}) where {T<:Interval}\n\nChecks whether the square interval matrix A is an M-matrix, that is a Z-matrix with non-negative inverse. For more details see section 4.2 of [HOR19].\n\nExamples\n\njulia> A = [2..2 -1..0; -1..0 2..2]\n2×2 Matrix{Interval{Float64}}:\n  [2, 2]  [-1, 0]\n [-1, 0]   [2, 2]\n\njulia> is_M_matrix(A)\ntrue\n\njulia> A = [2..4 -2..1; -1..2 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-2, 1]\n [-1, 2]   [2, 4]\n\njulia> is_M_matrix(A)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalLinearAlgebra.is_Z_matrix-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Interval","page":"API","title":"IntervalLinearAlgebra.is_Z_matrix","text":"is_Z_matrix(A::AbstractMatrix{T}) where {T<:Interval}\n\nChecks whether the square interval matrix A is a Z-matrix, that is whether Aᵢⱼ0 for all ij. For more details see section 4.2 of [HOR19].\n\nExamples\n\njulia> A = [2..4 -2.. -1; -2.. -1 2..4]\n2×2 Matrix{Interval{Float64}}:\n   [2, 4]  [-2, -1]\n [-2, -1]    [2, 4]\n\njulia> is_Z_matrix(A)\ntrue\n\njulia> A = [2..4 -2..1; -1..2 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-2, 1]\n [-1, 2]   [2, 4]\n\njulia> is_Z_matrix(A)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalLinearAlgebra.is_strictly_diagonally_dominant-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Interval","page":"API","title":"IntervalLinearAlgebra.is_strictly_diagonally_dominant","text":"is_strictly_diagonally_dominant(A::AbstractMatrix{T}) where {T<:Interval}\n\nChecks whether the square interval matrix A of order n is stictly diagonally dominant, that is if mig(Aᵢᵢ)  _k  i mag(Aᵢₖ) for i=1n. For more details see section 4.5 of [HOR19].\n\nExamples\n\njulia> A = [2..4 -1..1; -1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> is_strictly_diagonally_dominant(A)\ntrue\n\njulia> A = [2..4 -2..1; -1..2 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-2, 1]\n [-1, 2]   [2, 4]\n\njulia> is_strictly_diagonally_dominant(A)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalLinearAlgebra.is_strongly_regular-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Interval","page":"API","title":"IntervalLinearAlgebra.is_strongly_regular","text":"is_strongly_regular(A::AbstractMatrix{T}) where {T<:Interval}\n\nTests whether the square interval matrix A is strongly regular, i.e. if A_c^-1A is an H-matrix, where A_c is the midpoint matrix of A`. For more details see section 4.6 of [HOR19].\n\nExamples\n\njulia> A = [2..4 -2..1; -1..2 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-2, 1]\n [-1, 2]   [2, 4]\n\njulia> is_strongly_regular(A)\ntrue\n\njulia> A = [0..2 1..1;-1.. -1 0..2]\n2×2 Matrix{Interval{Float64}}:\n   [0, 2]  [1, 1]\n [-1, -1]  [0, 2]\n\njulia> is_strongly_regular(A)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalLinearAlgebra.oettli_eq-Tuple{Any, Any, Any}","page":"API","title":"IntervalLinearAlgebra.oettli_eq","text":"Returns the separator for the constraint |a_c ⋅x - b_c| - a_r ⋅|x| - b_r <= 0.\n\na and x must be vectors of the same length and b is scalar.\n\nThe absolue values in the equation are taken elementwise.\n\na_c and a_r are vectors containing midpoints and radii of the intervals in a. Similar b_c and b_r.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalLinearAlgebra.oettli_lhs-Tuple{Any, Any, Any}","page":"API","title":"IntervalLinearAlgebra.oettli_lhs","text":"returns the unrolled expression for a x - b a and x must be vectors of the same length and b is scalar. The absolue value in the equation is taken elementwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalLinearAlgebra.oettli_rhs-Tuple{Any, Any, Any}","page":"API","title":"IntervalLinearAlgebra.oettli_rhs","text":"returns the unrolled expression for a x + b a and x must be vectors of the same length and b is scalar. The absolue value in the equation is taken elementwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalLinearAlgebra.rref!-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Interval","page":"API","title":"IntervalLinearAlgebra.rref!","text":"rref!(A::AbstractMatrix{T}) where {T<:Interval}\n\nIn-place version of rref.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalLinearAlgebra.rref-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Interval","page":"API","title":"IntervalLinearAlgebra.rref","text":"rref(A::AbstractMatrix{T}) where {T<:Interval}\n\nComputes the reduced row echelon form of the interval matrix A using maximum mignitude as pivoting strategy.\n\nExamples\n\njulia> A = [2..4 -1..1; -1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> rref(A)\n2×2 Matrix{Interval{Float64}}:\n [2, 4]  [-1, 1]\n [0, 0]       [1.5, 4.5]\n\n\n\n\n\n","category":"method"},{"location":"wip/","page":"Tutorials","title":"Tutorials","text":"still work in progress, stay tuned!","category":"page"},{"location":"#IntervalLinearAlgebra.jl","page":"Home","title":"IntervalLinearAlgebra.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Linear algebra done rigorously","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for IntervalLinearAlgebra.jl, a package contains functionalities to solve numerical linear algebra tasks using interval arithmetic.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"!!! note The package is still under active development and everything can change overnight.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Different algorithms to compute the hull of interval linear systems\nclassify interval matrices\nrigorous solution of real linear systems\nexact characterization of the solution of interval linear systems using Oettli-Präger","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is not registered yet, it can be installed as","category":"page"},{"location":"","page":"Home","title":"Home","text":"(@v1.6) pkg> add https://github.com/lucaferranti/intervallinearalgebra.jl","category":"page"}]
}
