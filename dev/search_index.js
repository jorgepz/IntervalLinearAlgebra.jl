var documenterSearchIndex = {"docs":
[{"location":"references/#all_ref","page":"References","title":"References","text":"","category":"section"},{"location":"references/#[HOR19]","page":"References","title":"[HOR19]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"<ul><li>","category":"page"},{"location":"references/","page":"References","title":"References","text":"J. Horácek, Interval Linear and Nonlinear Systems, PhD dissertation, 2019","category":"page"},{"location":"references/","page":"References","title":"References","text":"<li style=\"list-style: none\"><details>\n<summary>bibtex</summary>","category":"page"},{"location":"references/","page":"References","title":"References","text":"@article{horavcek2019interval,\n  title={Interval linear and nonlinear systems},\n  author={Hor{\\'a}{\\v{c}}ek, Jaroslav},\n  year={2019},\n  publisher={Univerzita Karlova, Matematicko-fyzik{\\'a}ln{\\'\\i} fakulta}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"</details></li></ul>","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[JAU14]","page":"References","title":"[JAU14]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"<ul><li>","category":"page"},{"location":"references/","page":"References","title":"References","text":"L. Jaulin and B. Desrochers, Introduction to the algebra of separators with application to path planning, Engineering Applications of Artificial Intelligence 33 (2014): 141-147","category":"page"},{"location":"references/","page":"References","title":"References","text":"<li style=\"list-style: none\"><details>\n<summary>bibtex</summary>","category":"page"},{"location":"references/","page":"References","title":"References","text":"@article{jaulin2014introduction,\n  title={Introduction to the algebra of separators with application to path planning},\n  author={Jaulin, Luc and Desrochers, Beno{\\^\\i}t},\n  journal={Engineering Applications of Artificial Intelligence},\n  volume={33},\n  pages={141--147},\n  year={2014},\n  publisher={Elsevier}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"</details></li></ul>","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[NEU90]","page":"References","title":"[NEU90]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"<ul><li>","category":"page"},{"location":"references/","page":"References","title":"References","text":"A. Neumaier, Interval methods for systems of equations, Cambridge university press, 1990 ","category":"page"},{"location":"references/","page":"References","title":"References","text":"<li style=\"list-style: none\"><details>\n<summary>bibtex</summary>","category":"page"},{"location":"references/","page":"References","title":"References","text":"@book{neumaier1990interval,\n  title={Interval methods for systems of equations},\n  author={Neumaier, Arnold and Neumaier, Arnold},\n  number={37},\n  year={1990},\n  publisher={Cambridge university press}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"</details></li></ul>","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[OET64]","page":"References","title":"[OET64]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"<ul><li>","category":"page"},{"location":"references/","page":"References","title":"References","text":"W. Oettli and W. Prager, Compatibility of approximate solution of linear equa- tions with given error bounds for coefficients and right-hand sides, Numerische Mathematik, 6(1):405–409, 1964.","category":"page"},{"location":"references/","page":"References","title":"References","text":"<li style=\"list-style: none\"><details>\n<summary>bibtex</summary>","category":"page"},{"location":"references/","page":"References","title":"References","text":"@article{oettli1964compatibility,\n  title={Compatibility of approximate solution of linear equations with given error bounds for coefficients and right-hand sides},\n  author={Oettli, Werner and Prager, William},\n  journal={Numerische Mathematik},\n  volume={6},\n  number={1},\n  pages={405--409},\n  year={1964},\n  publisher={Springer}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"</details></li></ul>","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[ROH06]","page":"References","title":"[ROH06]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"<ul><li>","category":"page"},{"location":"references/","page":"References","title":"References","text":"J. Rohn. Solvability of systems of interval linear equations and inequalities, Linear optimization problems with inexact data, pages 35–77. Springer, 2006","category":"page"},{"location":"references/","page":"References","title":"References","text":"<li style=\"list-style: none\"><details>\n<summary>bibtex</summary>","category":"page"},{"location":"references/","page":"References","title":"References","text":"@incollection{rohn2006solvability,\n  title={Solvability of systems of interval linear equations and inequalities},\n  author={Rohn, Jir{\\i}},\n  booktitle={Linear optimization problems with inexact data},\n  pages={35--77},\n  year={2006},\n  publisher={Springer}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"</details></li></ul>","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[ROH95]","page":"References","title":"[ROH95]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"<ul><li>","category":"page"},{"location":"references/","page":"References","title":"References","text":"J. Rohn and V. Kreinovich. Computing exact componentwise bounds on solutions of lineary systems with interval data is NP-hard. SIAM Journal on Matrix Analysis and Applications, 16(2):415–420, 1995.","category":"page"},{"location":"references/","page":"References","title":"References","text":"<li style=\"list-style: none\"><details>\n<summary>bibtex</summary>","category":"page"},{"location":"references/","page":"References","title":"References","text":"@article{rohn1995computing,\n  title={Computing exact componentwise bounds on solutions of lineary systems with interval data is NP-hard},\n  author={Rohn, Jiri and Kreinovich, Vladik},\n  journal={SIAM Journal on Matrix Analysis and Applications},\n  volume={16},\n  number={2},\n  pages={415--420},\n  year={1995},\n  publisher={SIAM}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"</details></li></ul>","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[RUM10]","page":"References","title":"[RUM10]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"<ul><li>","category":"page"},{"location":"references/","page":"References","title":"References","text":"S.M. Rump, Verification methods: Rigorous results using floating-point arithmetic, Acta Numerica, 19:287–449, 2010","category":"page"},{"location":"references/","page":"References","title":"References","text":"<li style=\"list-style: none\"><details>\n<summary>bibtex</summary>","category":"page"},{"location":"references/","page":"References","title":"References","text":"@article{rump2010verification,\n  title={Verification methods: Rigorous results using floating-point arithmetic},\n  author={Rump, Siegfried M},\n  journal={Acta Numerica},\n  volume={19},\n  pages={287--449},\n  year={2010},\n  publisher={Cambridge University Press}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"</details></li></ul>","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[RUM99]","page":"References","title":"[RUM99]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"<ul><li>","category":"page"},{"location":"references/","page":"References","title":"References","text":"Rump, Siegfried M. Fast and parallel interval arithmetic, BIT Numerical Mathematics 39.3, 534-554, 1999","category":"page"},{"location":"references/","page":"References","title":"References","text":"<li style=\"list-style: none\"><details>\n<summary>bibtex</summary>","category":"page"},{"location":"references/","page":"References","title":"References","text":"@article{rump1999fast,\n  title={Fast and parallel interval arithmetic},\n  author={Rump, Siegfried M},\n  journal={BIT Numerical Mathematics},\n  volume={39},\n  number={3},\n  pages={534--554},\n  year={1999},\n  publisher={Springer}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"</details></li></ul>","category":"page"},{"location":"api/precondition/#Preconditioners","page":"Preconditioners","title":"Preconditioners","text":"","category":"section"},{"location":"api/precondition/","page":"Preconditioners","title":"Preconditioners","text":"Pages = [\"precondition.md\"]","category":"page"},{"location":"api/precondition/","page":"Preconditioners","title":"Preconditioners","text":"Modules=[IntervalLinearAlgebra]\nPages=[\"precondition.jl\"]\nPrivate=false","category":"page"},{"location":"api/precondition/#IntervalLinearAlgebra.InverseDiagonalMidpoint","page":"Preconditioners","title":"IntervalLinearAlgebra.InverseDiagonalMidpoint","text":"InverseDiagonalMidpoint <: AbstractPrecondition\n\nPreconditioner that preconditions the linear system Ax=b with the diagonal matrix of A_c^-1, where A_c is the midpoint matrix of A.\n\nNotes\n\nAn object of type InverseDiagonalMidpoint is a function with method\n  (idmp::InverseDiagonalMidpoint)(A::AbstractMatrix{T},\n                                  b::AbstractVector{T}) where {T<:Interval}\n\nExample\n\njulia> A = [2..4 -2..1; -1..2 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-2, 1]\n [-1, 2]   [2, 4]\n\njulia> b = [-2..2, -2..2]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-2, 2]\n\njulia> idmp = InverseDiagonalMidpoint()\nInverseDiagonalMidpoint()\n\njulia> idmp(A, b)\n(Interval{Float64}[[0.666666, 1.33334] [-0.666667, 0.333334]; [-0.333334, 0.666667] [0.666666, 1.33334]], Interval{Float64}[[-0.666667, 0.666667], [-0.666667, 0.666667]])\n\n\n\n\n\n","category":"type"},{"location":"api/precondition/#IntervalLinearAlgebra.InverseMidpoint","page":"Preconditioners","title":"IntervalLinearAlgebra.InverseMidpoint","text":"InverseMidpoint <: AbstractPrecondition\n\nPreconditioner that preconditions the linear system Ax=b with A_c^-1, where A_c is the midpoint matrix of A.\n\nNotes\n\nAn object of type InverseMidpoint is a function with method\n  (imp::InverseMidpoint)(A::AbstractMatrix{T},\n                         b::AbstractVector{T}) where {T<:Interval}\n\nExamples\n\njulia> A = [2..4 -2..1; -1..2 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-2, 1]\n [-1, 2]   [2, 4]\n\njulia> b = [-2..2, -2..2]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-2, 2]\n\njulia> imp = InverseMidpoint()\nInverseMidpoint()\n\njulia> imp(A, b)\n(Interval{Float64}[[0.594594, 1.40541] [-0.540541, 0.540541]; [-0.540541, 0.540541] [0.594594, 1.40541]], Interval{Float64}[[-0.756757, 0.756757], [-0.756757, 0.756757]])\n\n\n\n\n\n","category":"type"},{"location":"api/precondition/#IntervalLinearAlgebra.NoPrecondition","page":"Preconditioners","title":"IntervalLinearAlgebra.NoPrecondition","text":"NoPrecondition <: AbstractPrecondition\n\nType of the trivial preconditioner which does nothing.\n\nNotes\n\nAn object of type NoPrecondition is a function with method\n  (np::NoPrecondition)(A::AbstractMatrix{T},\n                       b::AbstractVector{T}) where {T<:Interval}\n\nExample\n\njulia> A = [2..4 -2..1; -1..2 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-2, 1]\n [-1, 2]   [2, 4]\n\njulia> b = [-2..2, -2..2]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-2, 2]\n\njulia> np = NoPrecondition()\nNoPrecondition()\n\njulia> np(A, b)\n(Interval{Float64}[[2, 4] [-2, 1]; [-1, 2] [2, 4]], Interval{Float64}[[-2, 2], [-2, 2]])\n\n\n\n\n\n","category":"type"},{"location":"explanations/preconditioning/#Preconditioning-interval-linear-systems","page":"Preconditioning","title":"Preconditioning interval linear systems","text":"","category":"section"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"Pages = [\"preconditioning.md\"]","category":"page"},{"location":"explanations/preconditioning/#Basic-concepts","page":"Preconditioning","title":"Basic concepts","text":"","category":"section"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"Consider the square interval linear system","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"mathbfAx=mathbfb","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"preconditioning the interval linear system by a real matrix C means to multiply both sides of the equation by C, obtaining the new system","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"CmathbfAx=Cmathbfb","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"which is called preconditioned system. Let us denote by A_c the midpoint matrix of mathbfA. Popular choices for C are","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"Inverse midpoint preconditioning: Capprox A_c^-1\nInverse diagonal midpoint preconditioning: Capprox D_A_c^-1 where D_A_c is the diagonal matrix containing the main diagonal of A_c.","category":"page"},{"location":"explanations/preconditioning/#Advantages-of-preconditioning","page":"Preconditioning","title":"Advantages of preconditioning","text":"","category":"section"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"Using preconditioning to solve an interval linear system can have mainly two advantages.","category":"page"},{"location":"explanations/preconditioning/#Extend-usability-of-algorithms","page":"Preconditioning","title":"Extend usability of algorithms","text":"","category":"section"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"Some algorithms require the matrix to have a specific structure in order to be used. For example Hansen-Bliek-Rohn algorithm requires mathbfA to be an H-matrix. However, the algorithm can be extended to work to strongly regular matrices using inverse midpoint preconditioning. (Recall that an interval matrix is strongly regular if A_c^-1mathbfA is an H-matrix).","category":"page"},{"location":"explanations/preconditioning/#Improve-numerical-stability","page":"Preconditioning","title":"Improve numerical stability","text":"","category":"section"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"Even if the algorithms theoretically work, they can be prone to numerical instability without preconditioning. This is demonstrated with the following example, a more deep theoretical analysis can be found in [NEU90].","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"Let mathbfA be an interval lower triangular matrix with all 1 1 in the lower part, for example","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"using IntervalLinearAlgebra\n\nN = 5 # problem dimension\nA = tril(fill(1..1, N, N))","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"and let mathbfb having -2 2 as first element and all other elements set to zero","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"b = vcat(-2..2, fill(0, N-1))","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"the \"pen and paper\" solution would be  -2 2 -2 2 0 0 0 0 0 0^mathsfT, that is a vector with -2 2 as first two elements and all other elements set to zero. Now, let us try to solve without preconditioning.","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"solve(A, b, GaussianElimination(), NoPrecondition())","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"solve(A, b, HansenBliekRohn(), NoPrecondition())","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"It can be seen that the width of the intervals grows exponentially, this gets worse with bigger matrices.","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"N = 100 # problem dimension\nA1 = tril(fill(1..1, N, N))\nb1 = [-2..2, fill(0..0, N-1)...]\n\nsolve(A1, b1, GaussianElimination(), NoPrecondition())","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"solve(A1, b1, HansenBliekRohn(), NoPrecondition())","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"However this numerical stability issue is solved using inverse midpoint preconditioning.","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"solve(A, b, GaussianElimination(), InverseMidpoint())","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"solve(A, b, HansenBliekRohn(), InverseMidpoint())","category":"page"},{"location":"explanations/preconditioning/#Disadvantages-of-preconditioning","page":"Preconditioning","title":"Disadvantages of preconditioning","text":"","category":"section"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"While preconditioning is useful, sometimes even necessary, to solve interval linear systems, it comes at a price. It is important to understand that the preconditioned interval linear system is not equivalent to the original one, particularly the preconditioned problem can have a larger solution set.","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"Let us consider the following linear system","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"A = [2..4 -2..1;-1..2 2..4]","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"b = [-2..2, -2..2]","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"Now we plot the solution set of the original and preconditioned problem using Oettli-Präger","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"using LazySets, Plots\n\npolytopes = solve(A, b, LinearOettliPrager())\npolytopes_precondition = solve(A, b, LinearOettliPrager(), InverseMidpoint())\n\nplot(UnionSetArray(polytopes_precondition), ratio=1, label=\"preconditioned\", legend=:right)\nplot!(UnionSetArray(polytopes), label=\"original\", α=1)\nxlabel!(\"x\")\nylabel!(\"y\")\nsavefig(\"solution_set_precondition.png\") # hide","category":"page"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"(Image: )","category":"page"},{"location":"explanations/preconditioning/#Take-home-lessons","page":"Preconditioning","title":"Take-home lessons","text":"","category":"section"},{"location":"explanations/preconditioning/","page":"Preconditioning","title":"Preconditioning","text":"Preconditioning an interval linear system can enlarge the solution set\nPreconditioning is sometimes needed to achieve numerical stability\nA rough rule of thumb (same used by IntervalLinearAlgebra.jl if no preconditioning is specified)\nnot needed for M-matrices and strictly diagonal dominant matrices\nmight be needed for H-matrices (IntervalLinearAlgebra.jl uses inverse midpoint by default with H-matrices)\nmust be used for strongly regular matrices","category":"page"},{"location":"wip/","page":"Applications","title":"Applications","text":"still work in progress, stay tuned!","category":"page"},{"location":"tutorials/linear_systems/#Linear-systems","page":"Linear systems","title":"Linear systems","text":"","category":"section"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"Pages = [\"linear_systems.md\"]","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"This tutorial will show you how to solve linear systems rigorously using IntervalLinearAlgebra.jl.","category":"page"},{"location":"tutorials/linear_systems/#Solve-interval-linear-systems","page":"Linear systems","title":"Solve interval linear systems","text":"","category":"section"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"An interval linear system mathbfAx=mathbfb is a linear system where mathbfA and mathbfb contain intervals. In general, the solution set mathbfx can have a complex non-convex shape and can thus be hard to characterize exactly (see this article for more details). Hence we are interested in finding an interval box containing mathbfx. In IntervalLinearAlgebra.jl, this is achieved through the solve function, which gives a handy interface to choose the algorithm and preconditioning mechanism. The syntax to call solve is ","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"solve(A, b, method, precondition)","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"A is an interval matrix\nb is an interval vector\nmethod is an optional parameter to choose the algorithm used to solve the interval linear system, see below for more details\nprecondition is an optional parameter to choose the preconditioning for the problem. More details about preconditoining can be found here","category":"page"},{"location":"tutorials/linear_systems/#Methods","page":"Linear systems","title":"Methods","text":"","category":"section"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"The supported methods are","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"Direct solvers\nGaussianElimination\nHansenBliekRohn\nLinearOettliPrager (requires importing LazySets.jl)\nIterative solvers\nLinearKrawczyk\nJacobi\nGaussSeidel\nNonLinearOettliPrager (requires importing IntervalConstraintProgramming.jl)","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"LinearOettliPrager and NonLinearOettliPrager are \"special\" in the sense that they try to exactly characterize the solution set using Oettli-Präger and are not considered in this tutorial. More information about them can be found here. The other solvers return a vector of intervals, representing an interval enclosure of the solution set. If the method is not specified, Gaussian elimination is used by default.","category":"page"},{"location":"tutorials/linear_systems/#Preconditioning","page":"Linear systems","title":"Preconditioning","text":"","category":"section"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"The supported preconditioning mechanisms are","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"NoPrecondition\nInverseMidpoint\nInverseDiagonalMidpoint","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"If preconditioning is not specified, then an heuristic strategy based on the type of matrix and solver is used to choose the preconditioning. The strategy is discussed at the end of the preconditioning tutorial.","category":"page"},{"location":"tutorials/linear_systems/#Examples","page":"Linear systems","title":"Examples","text":"","category":"section"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"We now demonstrate a few examples using the solve function, these examples are taken from [HOR19].","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"using IntervalLinearAlgebra\n\nA = [4..6 -1..1 -1..1 -1..1;-1..1 -6.. -4 -1..1 -1..1;-1..1 -1..1 9..11 -1..1;-1..1 -1..1 -1..1 -11.. -9]","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"b = [-2..4, 1..8, -4..10, 2..12]","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"solve(A, b, HansenBliekRohn())","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"solve(A, b, GaussianElimination())","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"solve(A, b, GaussSeidel())","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"For iterative methods, an additional optional parameter X0 representing an initial guess for the solution's enclosure can be given. If not given, a rough initial enclosure is computed using the enclose function.","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"X0 = fill(-5..5, 4)\nsolve(A, b, GaussSeidel(), InverseMidpoint(), X0)","category":"page"},{"location":"tutorials/linear_systems/#Verify-real-linear-systems","page":"Linear systems","title":"Verify real linear systems","text":"","category":"section"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"IntervalLinearAlgebra.jl also offers functionalities to solve real linear systems rigorously. It is of course possible to just convert the real system to an interval system and use the methods described above. In this situation, however, the system will have the property where the diameters of the intervals will be very small (zero or a few floating point units). To solve these kind of systems, it can be more efficient to use the epsilon inflation method [RUM10], especially for bigger matrices. Here is an example","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"A = [1.0 2;3 4]","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"b = [3, 7]","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"the real linear system Ax=b can now be solved rigorously using the epsilon_inflation function.","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"x, cert = epsilon_inflation(A, b)\n@show cert\nx","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"This function returns two values: an interval vector x and a boolean certificate cert. If cert==true then x is guaranteed to be an enclosure of the real linear system Ax=b. If cert == false then the algorithm could not verify that the enclosure is rigorous, i.e. it may or may not contain the true solution.","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"In the following example the epsilon inflation method returns a non-rigorous bound","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"A1 = [1..1+1e-16 2;3 4]\nx1, cert = epsilon_inflation(A1, b)\n@show cert\nx1","category":"page"},{"location":"tutorials/linear_systems/","page":"Linear systems","title":"Linear systems","text":"Since the matrix A1 is non-regular (it contains the matrix beginbmatrix1234endbmatrix which is singluar), the solution set is unbounded, hence the algorithm could not prove (rightly) that x1 is an enclosure of the true solution. ","category":"page"},{"location":"api/misc/#Miscellaneous","page":"Miscellaneous","title":"Miscellaneous","text":"","category":"section"},{"location":"api/misc/","page":"Miscellaneous","title":"Miscellaneous","text":"Other possibly useful functionalities.","category":"page"},{"location":"api/misc/","page":"Miscellaneous","title":"Miscellaneous","text":"Pages = [\"misc.md\"]","category":"page"},{"location":"api/misc/#Matrix-multiplication-API","page":"Miscellaneous","title":"Matrix multiplication API","text":"","category":"section"},{"location":"api/misc/","page":"Miscellaneous","title":"Miscellaneous","text":"set_multiplication_mode","category":"page"},{"location":"api/misc/#IntervalLinearAlgebra.set_multiplication_mode","page":"Miscellaneous","title":"IntervalLinearAlgebra.set_multiplication_mode","text":"set_multiplication_mode(multype)\n\nSets the algorithm used to perform matrix multiplication with interval matrices.\n\nInput\n\nmultype – symbol describing the algorithm used\n:slow – uses traditional matrix multiplication algorithm.\n:rank1 – uses rank1 update\n:fast – computes an enclosure of the matrix product using the midpoint-radius            notation of the matrix [RUM10].\n\nNotes\n\nBy default, :fast is used.\nUsing fast is generally significantly faster, but it may return larger intervals, especially if midpoint and radius have the same order of magnitude   (50% overestimate at most) [RUM99].\n\n\n\n\n\n","category":"function"},{"location":"api/misc/#Others","page":"Miscellaneous","title":"Others","text":"","category":"section"},{"location":"api/misc/","page":"Miscellaneous","title":"Miscellaneous","text":"Modules = [IntervalLinearAlgebra]\nPages = [\"utils.jl\", \"rref.jl\"]","category":"page"},{"location":"api/misc/#IntervalLinearAlgebra.Orthants","page":"Miscellaneous","title":"IntervalLinearAlgebra.Orthants","text":"Orthants\n\nIterator to go through all the 2ⁿ vectors of length n with elements 1. This is equivalento to going through the orthants of an n-dimensional euclidean space.\n\nFields\n\nn::Int – dimension of the vector space\n\nExample\n\njulia> for or in Orthants(2)\n       @show or\n       end\nor = [1, 1]\nor = [-1, 1]\nor = [1, -1]\nor = [-1, -1]\n\n\n\n\n\n","category":"type"},{"location":"api/misc/#IntervalLinearAlgebra.comparison_matrix-Union{Tuple{StaticArrays.SMatrix{N, N, T, M}}, Tuple{T}, Tuple{M}, Tuple{N}} where {N, M, T<:Interval}","page":"Miscellaneous","title":"IntervalLinearAlgebra.comparison_matrix","text":"comparison_matrix(A::AbstractMatrix{T}) where {T<:Interval}\n\nComputes the comparison matrix A of the given interval matrix A according to the definition Aᵢᵢ = mig(Aᵢᵢ) and Aᵢⱼ = -mag(Aᵢⱼ) if ij.\n\nExamples\n\njulia> A = [2..4 -1..1; -1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> comparison_matrix(A)\n2×2 Matrix{Float64}:\n  2.0  -1.0\n -1.0   2.0\n\n\n\n\n\n","category":"method"},{"location":"api/misc/#IntervalLinearAlgebra.enclose-Union{Tuple{T}, Tuple{N}, Tuple{StaticArrays.StaticMatrix{N, N, T}, StaticArrays.StaticVector{N, T}}} where {N, T<:Interval}","page":"Miscellaneous","title":"IntervalLinearAlgebra.enclose","text":"enclose(A::AbstractMatrix{T}, b::AbstractVector{T}) where {T<:Interval}\n\nComputes an enclosure of the solution of the interval linear system Ax=b using the algorithm described in sec. 5.7.1 of [HOR19].\n\n\n\n\n\n","category":"method"},{"location":"api/misc/#IntervalLinearAlgebra.interval_isapprox-Tuple{Interval, Interval}","page":"Miscellaneous","title":"IntervalLinearAlgebra.interval_isapprox","text":"interval_isapprox(a::Interval, b::Interval; kwargs)\n\nChecks whether the intervals a and b are approximate equal, that is both their lower and upper bound are approximately equal.\n\nKeywords\n\nSame of Base.isapprox\n\nExample\n\njulia> a = 1..2\n[1, 2]\n\njulia> b = a + 1e-10\n[1, 2.00001]\n\njulia> interval_isapprox(a, b)\ntrue\n\njulia> interval_isapprox(a, b; atol=1e-15)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api/misc/#IntervalLinearAlgebra.interval_norm-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Interval","page":"Miscellaneous","title":"IntervalLinearAlgebra.interval_norm","text":"interval_norm(A::AbstractMatrix{T}) where {T<:Interval}\n\ncomputes the infinity norm of interval matrix A.\n\nExamples\n\njulia> A = [2..4 -1..1; -1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> interval_norm(A)\n5.0\n\n\n\n\n\n","category":"method"},{"location":"api/misc/#IntervalLinearAlgebra.interval_norm-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:Interval","page":"Miscellaneous","title":"IntervalLinearAlgebra.interval_norm","text":"interval_norm(A::AbstractVector{T}) where {T<:Interval}\n\ncomputes the infinity norm of interval vector v.\n\nExamples\n\njulia> b = [-2..2, -3..2]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-3, 2]\n\njulia> interval_norm(b)\n3.0\n\n\n\n\n\n","category":"method"},{"location":"api/misc/#IntervalLinearAlgebra.rref!-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Interval","page":"Miscellaneous","title":"IntervalLinearAlgebra.rref!","text":"rref!(A::AbstractMatrix{T}) where {T<:Interval}\n\nIn-place version of rref.\n\n\n\n\n\n","category":"method"},{"location":"api/misc/#IntervalLinearAlgebra.rref-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Interval","page":"Miscellaneous","title":"IntervalLinearAlgebra.rref","text":"rref(A::AbstractMatrix{T}) where {T<:Interval}\n\nComputes the reduced row echelon form of the interval matrix A using maximum mignitude as pivoting strategy.\n\nExamples\n\njulia> A = [2..4 -1..1; -1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> rref(A)\n2×2 Matrix{Interval{Float64}}:\n [2, 4]  [-1, 1]\n [0, 0]       [1.5, 4.5]\n\n\n\n\n\n","category":"method"},{"location":"explanations/solution_set/#Solution-set-of-interval-linear-system","page":"Interval system solution set","title":"Solution set of interval linear system","text":"","category":"section"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"Pages=[\"solution_set.md\"]","category":"page"},{"location":"explanations/solution_set/#Interval-linear-systems","page":"Interval system solution set","title":"Interval linear systems","text":"","category":"section"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"An interval linear system is defined as","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"mathbfAmathbfx=mathbfb","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"where mathbfAinmathbbImathbbR^ntimes n and mathbfbinmathbbImathbbR^n are an interval matrix and vector, respectively.","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"The solution set  mathbfx is defined as","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"mathbfx = x in mathbbR^n  Ax=b text for some  AinmathbfA binmathbfb ","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"In other words, mathbfx is the set of solutions of the real linear systems Ax=b for some  AinmathbfA and binmathbfb. If the interval matrix mathbfA is regular, that is all AinmathbfA are invertible, then the solution set mathbfx will be non-empty and bounded. In general, checking for regularity of an interval matrix has exponential complexity.","category":"page"},{"location":"explanations/solution_set/#Solution-by-Monte-Carlo","page":"Interval system solution set","title":"Solution by Monte-Carlo","text":"","category":"section"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"A naive approach to solve an interval linear system would be to use Montecarlo, i.e. to randomly sample elements from the intervals and solve the several random real systems. Suppose we want to solve the linear system","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"beginbmatrix\n2 4-21\n-1 22 4\nendbmatrixmathbfx =\nbeginbmatrix\n-2 2\n-2 2\nendbmatrix","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"Since we are planning to solve several thousands of instances of the interval problem and we are working with small arrays, we can use StaticArrays.jl to speed up the computations.","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"using IntervalLinearAlgebra, StaticArrays \n\nA = @SMatrix [2..4 -2..1; -1..2 2..4]\nb = @SVector [-2..2, -2..2]\nnothing # hide","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"To perform Montecarlo, we need to sample from the intervals. This can be achieved using the rand function, for example ","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"rand(1..2)","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"we are now ready for our montecarlo simulation, let us solve 100000 random instances","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"N = 100000\n\nxs = [rand.(A)\\rand.(b) for _ in 1:N]\nnothing # hide","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"now we plot a 2D-histogram to inspect the distribution of the solutions.","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"using Plots\n\nx = [xs[i][1] for i in 1:N]\ny = [xs[i][2] for i in 1:N]\n\nhistogram2d(x, y, ratio=1)\nxlabel!(\"x\")\nylabel!(\"y\")\nsavefig(\"histogram-2d.png\") # hide","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"(Image: )","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"As we can see, most of the solutions seem to be condensed close to the origin, but repeating the experiments enough times we also got some solutions farther away, obtaining a star looking area. Now the question is, have we captured the whole solution set?","category":"page"},{"location":"explanations/solution_set/#Oettli-Präger-theorem","page":"Interval system solution set","title":"Oettli-Präger theorem","text":"","category":"section"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"The solution set mathbfx is exactly characterized by the Oettli-Präger theorem [OET64], which says that an interval linear system mathbfAmathbfx=mathbfb is equivalent to the set of real inequalities","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"A_cx-b_c le A_Deltax + b_Delta","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"where A_c and A_\\Delta are the midpoint and radius matrix of \\mathbf{A}, b_c and b_Delta are defined similarly. The absolute values are taken elementwise.","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"We have now transformed the set of interval equalities into a set of real inequalities. We can easily get rid of the absolute value on the left obtaining the system","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"begincases\nA_cx-b_c le A_Deltax + b_Delta\n-(A_cx-b_c) le A_Deltax + b_Delta\nendcases","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"We can remove the absolute value on the right by considering each orthant separately, obtaining 2^n linear inequalities, where n is the dimension of the problem.","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"Practically this means rewriting x=D_ex, where einpm 1^n and D_e is the diagonal matrix with e on the main diagonal. As there are 2^n possible instances of e, we will go through 2^n linear inequalities in the form","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"beginbmatrix\nA_c-A_Delta D_e\n-A_c-A_Delta D_e\nendbmatrixxle beginbmatrixb_Delta+b_cb_Delta-b_cendbmatrix","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"as this inequality is in the form tildeAxle tildeb its solution set will be a convex polytope. This has also an important theoretical consequence: the solution set of any interval linear system is composed by the union of 2^n convex polytopes (some possibly empty), each lying entirely in one orthant.","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"In IntervalLinearAlgebra.jl the polytopes composing the solution set can be found using the LinearOettliPrager() solver. Note that to use it you need to import LazySets.jl first.","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"using LazySets\n\npolytopes = solve(A, b, LinearOettliPrager())\n\nplot(polytopes, ratio=1, legend=:none)\nhistogram2d!(x, y)\nxlabel!(\"x\")\nylabel!(\"y\")\nsavefig(\"oettli.png\") # hide","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"(Image: )","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"As we can see, the original montecarlo approximation, despite the high number of iterations, could not cover the whole solution set.","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"Note also that the solution set is non-convex but is composed by 4 convex polygons, one in each orthant. This is a general property of interval linear systems. For example, let us consider the interval linear system","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"beginbmatrix\n45 450 20 2\n0 245 450 2\n0 20 2 45 45\nendbmatrixmathbfx=beginbmatrix-1 1\n-1 1\n-1 1endbmatrix","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"its solution set is depicted in the next picture.","category":"page"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"(Image: )","category":"page"},{"location":"explanations/solution_set/#Disadvantages-of-Oettli-Präger","page":"Interval system solution set","title":"Disadvantages of Oettli-Präger","text":"","category":"section"},{"location":"explanations/solution_set/","page":"Interval system solution set","title":"Interval system solution set","text":"As the number of orthants grows exponential with the dimension n, applying Oettli-Präger has exponential complexity and is thus practically unfeasible in higher dimensions. Moreover, also computing the interval hull of the solution set is NP-hard [ROH95]. For this reason, in practical applications polynomial time algorithms that return an interval enclosure of the solution set are used, although these may return an interval box strictly larger than the interval hull.","category":"page"},{"location":"api/classify/#Interval-matrices-classification","page":"Interval matrices classification","title":"Interval matrices classification","text":"","category":"section"},{"location":"api/classify/","page":"Interval matrices classification","title":"Interval matrices classification","text":"Pages = [\"classify.md\"]","category":"page"},{"location":"api/classify/","page":"Interval matrices classification","title":"Interval matrices classification","text":"Modules=[IntervalLinearAlgebra]\nPages = [\"classify.jl\"]","category":"page"},{"location":"api/classify/#IntervalLinearAlgebra.is_H_matrix-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Interval","page":"Interval matrices classification","title":"IntervalLinearAlgebra.is_H_matrix","text":"is_H_matrix(A::AbstractMatrix{T}) where {T<:Interval}\n\nTests whether the square interval matrix A is an H-matrix, by testing that A^-1e0, where e=1 1  1ᵀ. Note that in practice it tests that a floating point approximation of A^-1e satisfies the condition. For more details see section 4.4 of [HOR19].\n\nExamples\n\njulia> A = [2..4 -1..1; -1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> is_H_matrix(A)\ntrue\n\njulia> A = [2..4 -2..1; -1..2 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-2, 1]\n [-1, 2]   [2, 4]\n\njulia> is_H_matrix(A)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api/classify/#IntervalLinearAlgebra.is_M_matrix-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Interval","page":"Interval matrices classification","title":"IntervalLinearAlgebra.is_M_matrix","text":"is_M_matrix(A::AbstractMatrix{T}) where {T<:Interval}\n\nChecks whether the square interval matrix A is an M-matrix, that is a Z-matrix with non-negative inverse. For more details see section 4.2 of [HOR19].\n\nExamples\n\njulia> A = [2..2 -1..0; -1..0 2..2]\n2×2 Matrix{Interval{Float64}}:\n  [2, 2]  [-1, 0]\n [-1, 0]   [2, 2]\n\njulia> is_M_matrix(A)\ntrue\n\njulia> A = [2..4 -2..1; -1..2 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-2, 1]\n [-1, 2]   [2, 4]\n\njulia> is_M_matrix(A)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api/classify/#IntervalLinearAlgebra.is_Z_matrix-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Interval","page":"Interval matrices classification","title":"IntervalLinearAlgebra.is_Z_matrix","text":"is_Z_matrix(A::AbstractMatrix{T}) where {T<:Interval}\n\nChecks whether the square interval matrix A is a Z-matrix, that is whether Aᵢⱼ0 for all ij. For more details see section 4.2 of [HOR19].\n\nExamples\n\njulia> A = [2..4 -2.. -1; -2.. -1 2..4]\n2×2 Matrix{Interval{Float64}}:\n   [2, 4]  [-2, -1]\n [-2, -1]    [2, 4]\n\njulia> is_Z_matrix(A)\ntrue\n\njulia> A = [2..4 -2..1; -1..2 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-2, 1]\n [-1, 2]   [2, 4]\n\njulia> is_Z_matrix(A)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api/classify/#IntervalLinearAlgebra.is_strictly_diagonally_dominant-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Interval","page":"Interval matrices classification","title":"IntervalLinearAlgebra.is_strictly_diagonally_dominant","text":"is_strictly_diagonally_dominant(A::AbstractMatrix{T}) where {T<:Interval}\n\nChecks whether the square interval matrix A of order n is stictly diagonally dominant, that is if mig(Aᵢᵢ)  _k  i mag(Aᵢₖ) for i=1n. For more details see section 4.5 of [HOR19].\n\nExamples\n\njulia> A = [2..4 -1..1; -1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> is_strictly_diagonally_dominant(A)\ntrue\n\njulia> A = [2..4 -2..1; -1..2 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-2, 1]\n [-1, 2]   [2, 4]\n\njulia> is_strictly_diagonally_dominant(A)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api/classify/#IntervalLinearAlgebra.is_strongly_regular-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Interval","page":"Interval matrices classification","title":"IntervalLinearAlgebra.is_strongly_regular","text":"is_strongly_regular(A::AbstractMatrix{T}) where {T<:Interval}\n\nTests whether the square interval matrix A is strongly regular, i.e. if A_c^-1A is an H-matrix, where A_c is the midpoint matrix of A`. For more details see section 4.6 of [HOR19].\n\nExamples\n\njulia> A = [2..4 -2..1; -1..2 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-2, 1]\n [-1, 2]   [2, 4]\n\njulia> is_strongly_regular(A)\ntrue\n\njulia> A = [0..2 1..1;-1.. -1 0..2]\n2×2 Matrix{Interval{Float64}}:\n   [0, 2]  [1, 1]\n [-1, -1]  [0, 2]\n\njulia> is_strongly_regular(A)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api/solve/#General-inteface-for-solving-interval-linear-systems","page":"solver interface","title":"General inteface for solving interval linear systems","text":"","category":"section"},{"location":"api/solve/","page":"solver interface","title":"solver interface","text":"solve","category":"page"},{"location":"api/solve/#CommonSolve.solve","page":"solver interface","title":"CommonSolve.solve","text":"solve(A::AbstractMatrix{T},\n      b::AbstractVector{T},\n      solver::AbstractIterativeSolver,\n      [precondition]::AbstractPrecondition=_default_precondition(A, solver),\n      [X]::AbstractVector{T}=enclose(A, b)) where {T<:Interval}\n\nSolves the square interval system Ax=b using the given algorithm, preconditioner and initial enclosure\n\nInput\n\nA – square interval matrix\nb – interval vector\nsolver – algorithm used to solve the linear system\nprecondition – preconditioner used. If not given, it is automatically computed based on                   the matrix A and the solver.\nX – initial enclosure.        if not given, it is automatically computed using enclose\n\nExamples\n\njulia> A = [2..4 -1..1;-1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> b = [-2..2, -1..1]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-1, 1]\n\njulia> solve(A, b, GaussSeidel(), NoPrecondition(), [-10..10, -10..10])\n2-element Vector{Interval{Float64}}:\n [-1.66668, 1.66668]\n [-1.33334, 1.33334]\n\njulia> solve(A, b, GaussSeidel())\n2-element Vector{Interval{Float64}}:\n [-1.66667, 1.66667]\n [-1.33334, 1.33334]\n\n\n\n\n\nsolve(A::AbstractMatrix{T},\n      b::AbstractVector{T},\n      solver::AbstractDirectSolver,\n      [precondition]::AbstractPrecondition=_default_precondition(A, solver)) where\n      {T<:Interval}\n\nSolves the square interval system Ax=b using the given algorithm, preconditioner and initial enclosure\n\nInput\n\nA – square interval matrix\nb – interval vector\nsolver – algorithm used to solve the linear system\nprecondition – preconditioner used. If not given, it is automatically computed based on                   the matrix A and the solver.\n\nExamples\n\njulia> A = [2..4 -1..1;-1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> b = [-2..2, -1..1]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-1, 1]\n\njulia> solve(A, b, HansenBliekRohn(), InverseMidpoint())\n2-element Vector{Interval{Float64}}:\n [-1.66667, 1.66667]\n [-1.33334, 1.33334]\n\njulia> solve(A, b, HansenBliekRohn())\n2-element Vector{Interval{Float64}}:\n [-1.66667, 1.66667]\n [-1.33334, 1.33334]\n\n\n\n\n\nsolve(A::AbstractMatrix{T},\n      b::AbstractVector{T},\n      [solver]::AbstractLinearSolver,\n      [precondition]::AbstractPrecondition=_default_precondition(A, solver)) where\n      {T<:Interval}\n\nSolves the square interval system Ax=b using the given algorithm, preconditioner and initial enclosure\n\nInput\n\nA – square interval matrix\nb – interval vector\nsolver – algorithm used to solve the linear system. If not given,             GaussianElimination is used.\nprecondition – preconditioner used. If not given, it is automatically computed based on                   the matrix A and the solver.\n\nExamples\n\njulia> A = [2..4 -1..1;-1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> b = [-2..2, -1..1]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-1, 1]\n\njulia> solve(A, b)\n2-element Vector{Interval{Float64}}:\n [-1.66667, 1.66667]\n [-1.33334, 1.33334]\n\n\n\n\n\n","category":"function"},{"location":"api/epsilon_inflation/#Verified-real-linear-systems","page":"Verified real linear systems","title":"Verified real linear systems","text":"","category":"section"},{"location":"api/epsilon_inflation/","page":"Verified real linear systems","title":"Verified real linear systems","text":"Pages = [\"epsilon_inflation.md\"]","category":"page"},{"location":"api/epsilon_inflation/","page":"Verified real linear systems","title":"Verified real linear systems","text":"Modules = [IntervalLinearAlgebra]\nPages = [\"linear_systems/verify.jl\"]","category":"page"},{"location":"api/epsilon_inflation/#IntervalLinearAlgebra.epsilon_inflation-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractArray{S, N}}} where {T<:Real, S<:Real, N}","page":"Verified real linear systems","title":"IntervalLinearAlgebra.epsilon_inflation","text":"epsilon_inflation(A::AbstractMatrix{T}, b::AbstractArray{S, N};\n                  r=0.1, ϵ=1e-20, iter_max=20) where {T<:Real, S<:Real, N}\n\nepsilon_inflation(A::AbstractMatrix{T}, b::AbstractArray{S, N};\n                  r=0.1, ϵ=1e-20, iter_max=20) where {T<:Interval, S<:Interval, N}\n\nGives an enclosure of the solution of the square linear system Ax=b using the ϵ-inflation algorithm,  see algorithm 10.7 of [RUM10]\n\nInput\n\nA        – square matrix of size n × n\nb        – vector of length n or matrix of size n × m\nr        – relative inflation, default 10%\nϵ        – absolute inflation, default 1e-20\niter_max – maximum number of iterations\n\nOutput\n\nx    – enclosure of the solution of the linear system\ncert – Boolean flag, if cert==true, then x is certified to contain the true\n\nsolution of the linear system, if cert==false, then the algorithm could not prove that x actually contains the true solution.\n\nAlgorithm\n\nGiven the real system Ax=b and an approximate solution x, we initialize x₀ = x x. At each iteration the algorithm computes the inflation\n\ny = xₖ * 1 - r 1 + r + -ϵ ϵ\n\nand the update\n\nxₖ₁ = Z + (I - CA)y,\n\nwhere Z = C(b - Ax₀) and C is an approximate inverse of A. If the condition xₖ₁  y is met, then xₖ₁ is a proved enclosure of A¹b and cert is set to true. If the condition is not met by the maximum number of iterations, the latest computed enclosure is returned, but cert is set to false, meaning the algorithm could not prove that the enclosure contains the true solution. For interval systems, x is obtained considering the midpoint of A and b.\n\nNotes\n\nThis algorithm is meant for real linear systems, or interval systems with\n\nvery tiny intervals. For interval linear systems with wider intervals, see the solve function.\n\nExamples\n\njulia> A = [1 2;3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> b = A * ones(2)\n2-element Vector{Float64}:\n 3.0\n 7.0\n\njulia> x, cert = epsilon_inflation(A, b)\n(Interval{Float64}[[0.999999, 1.00001], [0.999999, 1.00001]], true)\n\njulia> ones(2) .∈ x\n2-element BitVector:\n 1\n 1\n\njulia> cert\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#IntervalLinearAlgebra.jl","page":"Home","title":"IntervalLinearAlgebra.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: License: MIT) (Image: Build Status) (Image: Coverage) (Image: Dev)","category":"page"},{"location":"","page":"Home","title":"Home","text":"<p align=\"center\">\n    <img src=\"assets/logo.png\" alt=\"IntervalLinearAlgebra.jl\" width=\"450\"/>\n</p>\n\n <p align=\"center\">\n <i>Linear algebra done rigorously</i></p>","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for IntervalLinearAlgebra.jl, a package contains functionalities to solve numerical linear algebra tasks using interval arithmetic.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"note: Note\nThe package is still under active development and everything can change overnight.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Different algorithms to enclose the solution of an interval linear system\nclassify interval matrices\nrigorous solution of real linear systems\nexact characterization of the solution of interval linear systems using Oettli-Präger","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is not registered yet, it can be installed as","category":"page"},{"location":"","page":"Home","title":"Home","text":"(@v1.6) pkg> add https://github.com/lucaferranti/intervallinearalgebra.jl","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using IntervalLinearAlgebra, LazySets, Plots\n\nA = [2..4 -1..1;-1..1 2..4]\nb = [-2..2, -1..1]\n\nXenclose = solve(A, b)\npolytopes = solve(A, b, LinearOettliPrager())\n\nplot(UnionSetArray(polytopes), ratio=1, label=\"solution set\", legend=:top)\nplot!(IntervalBox(Xenclose), label=\"enclosure\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: quickstart-example)","category":"page"},{"location":"api/algorithms/#Algorithms","page":"Interval linear systems","title":"Algorithms","text":"","category":"section"},{"location":"api/algorithms/","page":"Interval linear systems","title":"Interval linear systems","text":"Algorithms used to solve interval linear systems.","category":"page"},{"location":"api/algorithms/","page":"Interval linear systems","title":"Interval linear systems","text":"Pages=[\"algorithms.md\"]","category":"page"},{"location":"api/algorithms/#Enclosure-computation","page":"Interval linear systems","title":"Enclosure computation","text":"","category":"section"},{"location":"api/algorithms/#Direct-methods","page":"Interval linear systems","title":"Direct methods","text":"","category":"section"},{"location":"api/algorithms/","page":"Interval linear systems","title":"Interval linear systems","text":"GaussianElimination\nHansenBliekRohn","category":"page"},{"location":"api/algorithms/#IntervalLinearAlgebra.GaussianElimination","page":"Interval linear systems","title":"IntervalLinearAlgebra.GaussianElimination","text":"GaussianElimination <: AbstractDirectSolver\n\nType for the Gaussian elimination solver of the square interval linear system Ax=b. For more details see section 5.6.1 of [HOR19]\n\nNotes\n\nAn object of type GaussianElimination is a callable function with method\n  (ge::GaussianElimination)(A::AbstractMatrix{T},\n                            b::AbstractVector{T}) where {T<:Interval}\n\nExamples\n\njulia> A = [2..4 -1..1;-1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> b = [-2..2, -1..1]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-1, 1]\n\njulia> ge = GaussianElimination()\nGaussianElimination linear solver\n\njulia> ge(A, b)\n2-element Vector{Interval{Float64}}:\n [-1.66667, 1.66667]\n [-1.33334, 1.33334]\n\n\n\n\n\n","category":"type"},{"location":"api/algorithms/#IntervalLinearAlgebra.HansenBliekRohn","page":"Interval linear systems","title":"IntervalLinearAlgebra.HansenBliekRohn","text":"HansenBliekRohn <: AbstractDirectSolver\n\nType for the HansenBliekRohn solver of the square interval linear system Ax=b. For more details see section 5.6.2 of [HOR19]\n\nNotes\n\nHansen-Bliek-Rohn works with H-matrices without precondition and with strongly regular matrices using InverseMidpoint precondition\nIf the midpoint of A is a diagonal matrix, then the algorithm returns the exact hull.\nAn object of type Hansen-Bliek-Rohn is a callable function with method\n  (hbr::HansenBliekRohn)(A::AbstractMatrix{T},\n                         b::AbstractVector{T}) where {T<:Interval}\n\nExamples\n\njulia> A = [2..4 -1..1;-1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> b = [-2..2, -1..1]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-1, 1]\n\njulia> hbr = HansenBliekRohn()\nHansenBliekRohn linear solver\n\njulia> hbr(A, b)\n2-element Vector{Interval{Float64}}:\n [-1.66667, 1.66667]\n [-1.33334, 1.33334]\n\n\n\n\n\n","category":"type"},{"location":"api/algorithms/#Iterative-methods","page":"Interval linear systems","title":"Iterative methods","text":"","category":"section"},{"location":"api/algorithms/","page":"Interval linear systems","title":"Interval linear systems","text":"GaussSeidel\nJacobi\nLinearKrawczyk","category":"page"},{"location":"api/algorithms/#IntervalLinearAlgebra.GaussSeidel","page":"Interval linear systems","title":"IntervalLinearAlgebra.GaussSeidel","text":"GaussSeidel <: AbstractIterativeSolver\n\nType for the Gauss-Seidel solver of the interval linear system Ax=b. For details see Section 5.7.4 of [HOR19]\n\nFields\n\nmax_iterations – maximum number of iterations (default 20)\natol           – absolute tolerance (default 0), if at some point xₖ - xₖ₁  atol                     (elementwise), then stop and return xₖ₁.                     If atol=0, then min(diam(A))*1e-5 is used.\n\nNotes\n\nAn object of type GaussSeidel is a function with method\n  (gs::GaussSeidel)(A::AbstractMatrix{T},\n                    b::AbstractVector{T},\n                    [x]::AbstractVector{T}=enclose(A, b)) where {T<:Interval}\nInput\nA   – N×N interval matrix\nb   – interval vector of length N\nx   – (optional) initial enclosure for the solution of Ax = b. If not given,          it is automatically computed using enclose\n\nExamples\n\njulia> A = [2..4 -1..1;-1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> b = [-2..2, -1..1]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-1, 1]\n\njulia> gs = GaussSeidel()\nGaussSeidel linear solver\nmax_iterations = 20\natol = 0.0\n\njulia> gs(A, b)\n2-element Vector{Interval{Float64}}:\n [-1.66668, 1.66668]\n [-1.33334, 1.33334]\n\n\n\n\n\n","category":"type"},{"location":"api/algorithms/#IntervalLinearAlgebra.Jacobi","page":"Interval linear systems","title":"IntervalLinearAlgebra.Jacobi","text":"Jacobi <: AbstractIterativeSolver\n\nType for the Jacobi solver of the interval linear system Ax=b. For details see Section 5.7.4 of [HOR19]\n\nFields\n\nmax_iterations – maximum number of iterations (default 20)\natol           – absolute tolerance (default 0), if at some point xₖ - xₖ₁  atol                     (elementwise), then stop and return xₖ₁.                     If atol=0, then min(diam(A))*1e-5 is used.\n\nNotes\n\nAn object of type Jacobi is a function with method\n  (jac::Jacobi)(A::AbstractMatrix{T},\n                b::AbstractVector{T},\n                [x]::AbstractVector{T}=enclose(A, b)) where {T<:Interval}\nInput\nA   – N×N interval matrix\nb   – interval vector of length N\nx   – (optional) initial enclosure for the solution of Ax = b. If not given,          it is automatically computed using enclose\n\nExamples\n\njulia> A = [2..4 -1..1;-1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> b = [-2..2, -1..1]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-1, 1]\n\njulia> jac = Jacobi()\nJacobi linear solver\nmax_iterations = 20\natol = 0.0\n\njulia> jac(A, b)\n2-element Vector{Interval{Float64}}:\n [-1.66668, 1.66668]\n [-1.33335, 1.33335]\n\n\n\n\n\n","category":"type"},{"location":"api/algorithms/#IntervalLinearAlgebra.LinearKrawczyk","page":"Interval linear systems","title":"IntervalLinearAlgebra.LinearKrawczyk","text":"LinearKrawczyk <: AbstractIterativeSolver\n\nType for the Krawczyk solver of the interval linear system Ax=b. For details see Section 5.7.3 of [HOR19]\n\nFields\n\nmax_iterations – maximum number of iterations (default 20)\natol           – absolute tolerance (default 0), if at some point xₖ - xₖ₁  atol                     (elementwise), then stop and return xₖ₁.                     If atol=0, then min(diam(A))*1e-5 is used.\n\nNotes\n\nAn object of type LinearKrawczyk is a function with method\n  (kra::LinearKrawczyk)(A::AbstractMatrix{T},\n                        b::AbstractVector{T},\n                        [x]::AbstractVector{T}=enclose(A, b)) where {T<:Interval}\nInput\nA   – N×N interval matrix\nb   – interval vector of length N\nx   – (optional) initial enclosure for the solution of Ax = b. If not given,          it is automatically computed using enclose\n\nExamples\n\njulia> A = [2..4 -1..1;-1..1 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-1, 1]\n [-1, 1]   [2, 4]\n\njulia> b = [-2..2, -1..1]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-1, 1]\n\njulia> kra = LinearKrawczyk()\nLinearKrawczyk linear solver\nmax_iterations = 20\natol = 0.0\n\njulia> kra(A, b)\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-2, 2]\n\n\n\n\n\n","category":"type"},{"location":"api/algorithms/#Exact-characterization","page":"Interval linear systems","title":"Exact characterization","text":"","category":"section"},{"location":"api/algorithms/","page":"Interval linear systems","title":"Interval linear systems","text":"LinearOettliPrager\nNonLinearOettliPrager","category":"page"},{"location":"api/algorithms/#IntervalLinearAlgebra.LinearOettliPrager","page":"Interval linear systems","title":"IntervalLinearAlgebra.LinearOettliPrager","text":"LinearOettliPrager <: AbstractDirectSolver\n\nType for the OettliPrager solver of the interval linear system Ax=b. The solver first converts the system of interval equalities into a system of real inequalities using Oettli-Präger theorem [OET64] and then finds the feasible set by solving a LP problem in each orthant using LazySets.jl.\n\nNotes\n\nYou need to import LazySets.jl to use this functionality.\nAn object of type LinearOettliPrager is a function with methods\n  (op::LinearOettliPrager)(A::AbstractMatrix{T},\n                           b::AbstractVector{T}) where {T<:Interval}\nInput\nA   – N×N interval matrix\nb   – interval vector of length N\n\nExamples\n\njulia> A = [2..4 -2..1;-1..2 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-2, 1]\n [-1, 2]   [2, 4]\n\njulia> b = [-2..2, -2..2]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-2, 2]\n\njulia> polytopes = solve(A, b, LinearOettliPrager());\n\njulia> typeof(polytopes)\nVector{HPolytope{Float64, SparseArrays.SparseVector{Float64, Int64}}}\n\n\n\n\n\n","category":"type"},{"location":"api/algorithms/#IntervalLinearAlgebra.NonLinearOettliPrager","page":"Interval linear systems","title":"IntervalLinearAlgebra.NonLinearOettliPrager","text":"NonLinearOettliPrager <: AbstractIterativeSolver\n\nType for the OettliPrager solver of the interval linear system Ax=b. The solver first converts the system of interval equalities into a system of real inequalities using Oettli-Präger theorem [OET64] and then finds the feasible set using the forward-backward contractor method [JAU14] implemented in IntervalConstraintProgramming.jl.\n\nFields\n\ntol – tolerance for the paving, default 0.01.\n\nNotes\n\nYou need to import IntervalConstraintProgramming.jl to use this functionality.\nAn object of type NonLinearOettliPrager is a function with methods\n  (op::NonLinearOettliPrager)(A::AbstractMatrix{T},\n                              b::AbstractVector{T},\n                              [X]::AbstractVector{T}=enclose(A, b)) where {T<:Interval}\n\n  (op::NonLinearOettliPrager)(A::AbstractMatrix{T},\n                              b::AbstractVector{T},\n                              X::IntervalBox) where {T<:Interval}\nInput\nA   – N×N interval matrix\nb   – interval vector of length N\nX   – (optional) initial enclosure for the solution of Ax = b. If not given,          it is automatically computed using enclose\n\nExamples\n\njulia> A = [2..4 -2..1;-1..2 2..4]\n2×2 Matrix{Interval{Float64}}:\n  [2, 4]  [-2, 1]\n [-1, 2]   [2, 4]\n\njulia> b = [-2..2, -2..2]\n2-element Vector{Interval{Float64}}:\n [-2, 2]\n [-2, 2]\n\njulia> solve(A, b, NonLinearOettliPrager(0.1))\nPaving:\n- tolerance ϵ = 0.1\n- inner approx. of length 1195\n- boundary approx. of length 823\n\n\n\n\n\n","category":"type"}]
}
