<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · IntervalLinearAlgebra.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://lucaferranti.github.io/IntervalLinearAlgebra.jl/api/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="IntervalLinearAlgebra.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">IntervalLinearAlgebra.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../wip/">Tutorials</a></li><li><a class="tocitem" href="../wip/">Applications</a></li><li><a class="tocitem" href="../wip/">Explanations</a></li><li class="is-active"><a class="tocitem" href>API</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/lucaferranti/IntervalLinearAlgebra.jl/blob/master/docs/src/api.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="IntervalLinearAlgebra"><a class="docs-heading-anchor" href="#IntervalLinearAlgebra">IntervalLinearAlgebra</a><a id="IntervalLinearAlgebra-1"></a><a class="docs-heading-anchor-permalink" href="#IntervalLinearAlgebra" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/lucaferranti/IntervalLinearAlgebra.jl">IntervalLinearAlgebra</a>.</p><ul><li><a href="#IntervalLinearAlgebra.AbstractDirectSolver"><code>IntervalLinearAlgebra.AbstractDirectSolver</code></a></li><li><a href="#IntervalLinearAlgebra.AbstractIterativeSolver"><code>IntervalLinearAlgebra.AbstractIterativeSolver</code></a></li><li><a href="#IntervalLinearAlgebra.AbstractLinearSolver"><code>IntervalLinearAlgebra.AbstractLinearSolver</code></a></li><li><a href="#IntervalLinearAlgebra.AbstractPrecondition"><code>IntervalLinearAlgebra.AbstractPrecondition</code></a></li><li><a href="#IntervalLinearAlgebra.GaussSeidel"><code>IntervalLinearAlgebra.GaussSeidel</code></a></li><li><a href="#IntervalLinearAlgebra.GaussianElimination"><code>IntervalLinearAlgebra.GaussianElimination</code></a></li><li><a href="#IntervalLinearAlgebra.HansenBliekRohn"><code>IntervalLinearAlgebra.HansenBliekRohn</code></a></li><li><a href="#IntervalLinearAlgebra.InverseDiagonalMidpoint"><code>IntervalLinearAlgebra.InverseDiagonalMidpoint</code></a></li><li><a href="#IntervalLinearAlgebra.InverseMidpoint"><code>IntervalLinearAlgebra.InverseMidpoint</code></a></li><li><a href="#IntervalLinearAlgebra.Jacobi"><code>IntervalLinearAlgebra.Jacobi</code></a></li><li><a href="#IntervalLinearAlgebra.LinearKrawczyk"><code>IntervalLinearAlgebra.LinearKrawczyk</code></a></li><li><a href="#IntervalLinearAlgebra.NoPrecondition"><code>IntervalLinearAlgebra.NoPrecondition</code></a></li><li><a href="#IntervalLinearAlgebra.NonLinearOettliPrager"><code>IntervalLinearAlgebra.NonLinearOettliPrager</code></a></li><li><a href="#IntervalLinearAlgebra.comparison_matrix-Union{Tuple{StaticArrays.SMatrix{N, N, T, M}}, Tuple{T}, Tuple{M}, Tuple{N}} where {N, M, T&lt;:Interval}"><code>IntervalLinearAlgebra.comparison_matrix</code></a></li><li><a href="#IntervalLinearAlgebra.enclose-Union{Tuple{T}, Tuple{N}, Tuple{StaticArrays.StaticMatrix{N, N, T}, StaticArrays.StaticVector{N, T}}} where {N, T&lt;:Interval}"><code>IntervalLinearAlgebra.enclose</code></a></li><li><a href="#IntervalLinearAlgebra.interval_isapprox-Tuple{Interval, Interval}"><code>IntervalLinearAlgebra.interval_isapprox</code></a></li><li><a href="#IntervalLinearAlgebra.interval_norm-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Interval"><code>IntervalLinearAlgebra.interval_norm</code></a></li><li><a href="#IntervalLinearAlgebra.interval_norm-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Interval"><code>IntervalLinearAlgebra.interval_norm</code></a></li><li><a href="#IntervalLinearAlgebra.is_H_matrix-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Interval"><code>IntervalLinearAlgebra.is_H_matrix</code></a></li><li><a href="#IntervalLinearAlgebra.is_M_matrix-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Interval"><code>IntervalLinearAlgebra.is_M_matrix</code></a></li><li><a href="#IntervalLinearAlgebra.is_Z_matrix-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Interval"><code>IntervalLinearAlgebra.is_Z_matrix</code></a></li><li><a href="#IntervalLinearAlgebra.is_strictly_diagonally_dominant-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Interval"><code>IntervalLinearAlgebra.is_strictly_diagonally_dominant</code></a></li><li><a href="#IntervalLinearAlgebra.is_strongly_regular-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Interval"><code>IntervalLinearAlgebra.is_strongly_regular</code></a></li><li><a href="#IntervalLinearAlgebra.oettli_eq-Tuple{Any, Any, Any}"><code>IntervalLinearAlgebra.oettli_eq</code></a></li><li><a href="#IntervalLinearAlgebra.oettli_lhs-Tuple{Any, Any, Any}"><code>IntervalLinearAlgebra.oettli_lhs</code></a></li><li><a href="#IntervalLinearAlgebra.oettli_rhs-Tuple{Any, Any, Any}"><code>IntervalLinearAlgebra.oettli_rhs</code></a></li><li><a href="#IntervalLinearAlgebra.rref-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Interval"><code>IntervalLinearAlgebra.rref</code></a></li><li><a href="#IntervalLinearAlgebra.rref!-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Interval"><code>IntervalLinearAlgebra.rref!</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="IntervalLinearAlgebra.AbstractDirectSolver" href="#IntervalLinearAlgebra.AbstractDirectSolver"><code>IntervalLinearAlgebra.AbstractDirectSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractDirectSolver &lt;: AbstractLinearSolver</code></pre><p>Abstract type for direct solvers of interval linear systems, such as Gaussian elimination and Hansen-Bliek-Rohn.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucaferranti/IntervalLinearAlgebra.jl/blob/c107915c7acef9dfc0f76f958030b88649a102f2/src/solvers/hull.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalLinearAlgebra.AbstractIterativeSolver" href="#IntervalLinearAlgebra.AbstractIterativeSolver"><code>IntervalLinearAlgebra.AbstractIterativeSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractIterativeSolver &lt;: AbstractLinearSolver</code></pre><p>Abstract type for iterative solvers of interval linear systems, such as Jacobi or Gauss-Seidel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucaferranti/IntervalLinearAlgebra.jl/blob/c107915c7acef9dfc0f76f958030b88649a102f2/src/solvers/hull.jl#L16-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalLinearAlgebra.AbstractLinearSolver" href="#IntervalLinearAlgebra.AbstractLinearSolver"><code>IntervalLinearAlgebra.AbstractLinearSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractLinearSolver</code></pre><p>Abstract type for solvers of interval linear systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucaferranti/IntervalLinearAlgebra.jl/blob/c107915c7acef9dfc0f76f958030b88649a102f2/src/solvers/hull.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalLinearAlgebra.AbstractPrecondition" href="#IntervalLinearAlgebra.AbstractPrecondition"><code>IntervalLinearAlgebra.AbstractPrecondition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractPrecondition</code></pre><p>Abstract type for preconditioners of interval linear systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucaferranti/IntervalLinearAlgebra.jl/blob/c107915c7acef9dfc0f76f958030b88649a102f2/src/solvers/precondition.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalLinearAlgebra.GaussSeidel" href="#IntervalLinearAlgebra.GaussSeidel"><code>IntervalLinearAlgebra.GaussSeidel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GaussSeidel &lt;: AbstractIterativeSolver</code></pre><p>Type for the Gauss-Seidel solver of the interval linear system <span>$Ax=b$</span>. For details see Section 5.7.4 of <a href="../references/#[HOR19]">[HOR19]</a></p><p><strong>Fields</strong></p><ul><li><code>max_iterations</code> – maximum number of iterations (default 20)</li><li><code>atol</code>           – absolute tolerance (default 0), if at some point <span>$|xₖ - xₖ₊₁| &lt; atol$</span>                     (elementwise), then stop and return <span>$xₖ₊₁$</span>.                     If <code>atol=0</code>, then <code>min(diam(A))*1e-5</code> is used.</li></ul><p><strong>Notes</strong></p><ul><li><p>An object of type <code>GaussSeidel</code> is a function with method</p><pre><code class="nohighlight">  (gs::GaussSeidel)(A::AbstractMatrix{T},
                    b::AbstractVector{T},
                    [x]::AbstractVector{T}=enclose(A, b)) where {T&lt;:Interval}</code></pre><h4>Input</h4><ul><li><code>A</code>   – N×N interval matrix</li><li><code>b</code>   – interval vector of length N</li><li><code>x</code>   – (optional) initial enclosure for the solution of <span>$Ax = b$</span>. If not given,          it is automatically computed using <a href="#IntervalLinearAlgebra.enclose-Union{Tuple{T}, Tuple{N}, Tuple{StaticArrays.StaticMatrix{N, N, T}, StaticArrays.StaticVector{N, T}}} where {N, T&lt;:Interval}"><code>enclose</code></a></li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [2..4 -1..1;-1..1 2..4]
2×2 Matrix{Interval{Float64}}:
  [2, 4]  [-1, 1]
 [-1, 1]   [2, 4]

julia&gt; b = [-2..2, -1..1]
2-element Vector{Interval{Float64}}:
 [-2, 2]
 [-1, 1]

julia&gt; gs = GaussSeidel()
GaussSeidel linear solver
max_iterations = 20
atol = 0.0

julia&gt; gs(A, b)
2-element Vector{Interval{Float64}}:
 [-1.66668, 1.66668]
 [-1.33334, 1.33334]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucaferranti/IntervalLinearAlgebra.jl/blob/c107915c7acef9dfc0f76f958030b88649a102f2/src/solvers/hull.jl#L212-L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalLinearAlgebra.GaussianElimination" href="#IntervalLinearAlgebra.GaussianElimination"><code>IntervalLinearAlgebra.GaussianElimination</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GaussianElimination &lt;: AbstractDirectSolver</code></pre><p>Type for the Gaussian elimination solver of the square interval linear system <span>$Ax=b$</span>. For more details see section 5.6.1 of <a href="../references/#[HOR19]">[HOR19]</a></p><p><strong>Notes</strong></p><ul><li><p>An object of type <code>GaussianElimination</code> is a callable function with method</p><pre><code class="nohighlight">  (ge::GaussianElimination)(A::AbstractMatrix{T},
                            b::AbstractVector{T}) where {T&lt;:Interval}</code></pre></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [2..4 -1..1;-1..1 2..4]
2×2 Matrix{Interval{Float64}}:
  [2, 4]  [-1, 1]
 [-1, 1]   [2, 4]

julia&gt; b = [-2..2, -1..1]
2-element Vector{Interval{Float64}}:
 [-2, 2]
 [-1, 1]

julia&gt; ge = GaussianElimination()
GaussianElimination linear solver

julia&gt; ge(A, b)
2-element Vector{Interval{Float64}}:
 [-1.66667, 1.66667]
 [-1.33334, 1.33334]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucaferranti/IntervalLinearAlgebra.jl/blob/c107915c7acef9dfc0f76f958030b88649a102f2/src/solvers/hull.jl#L79-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalLinearAlgebra.HansenBliekRohn" href="#IntervalLinearAlgebra.HansenBliekRohn"><code>IntervalLinearAlgebra.HansenBliekRohn</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HansenBliekRohn &lt;: AbstractDirectSolver</code></pre><p>Type for the <code>HansenBliekRohn</code> solver of the square interval linear system <span>$Ax=b$</span>. For more details see section 5.6.2 of <a href="../references/#[HOR19]">[HOR19]</a></p><p><strong>Notes</strong></p><ul><li><p>Hansen-Bliek-Rohn works with H-matrices without precondition and with strongly regular matrices using <a href="#IntervalLinearAlgebra.InverseMidpoint"><code>InverseMidpoint</code></a> precondition</p></li><li><p>If the midpoint of <span>$A$</span> is a diagonal matrix, then the algorithm returns the exact hull.</p></li><li><p>An object of type Hansen-Bliek-Rohn is a callable function with method</p><pre><code class="nohighlight">  (hbr::HansenBliekRohn)(A::AbstractMatrix{T},
                         b::AbstractVector{T}) where {T&lt;:Interval}</code></pre></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [2..4 -1..1;-1..1 2..4]
2×2 Matrix{Interval{Float64}}:
  [2, 4]  [-1, 1]
 [-1, 1]   [2, 4]

julia&gt; b = [-2..2, -1..1]
2-element Vector{Interval{Float64}}:
 [-2, 2]
 [-1, 1]

julia&gt; hbr = HansenBliekRohn()
HansenBliekRohn linear solver

julia&gt; hbr(A, b)
2-element Vector{Interval{Float64}}:
 [-1.66667, 1.66667]
 [-1.33334, 1.33334]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucaferranti/IntervalLinearAlgebra.jl/blob/c107915c7acef9dfc0f76f958030b88649a102f2/src/solvers/hull.jl#L24-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalLinearAlgebra.InverseDiagonalMidpoint" href="#IntervalLinearAlgebra.InverseDiagonalMidpoint"><code>IntervalLinearAlgebra.InverseDiagonalMidpoint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InverseDiagonalMidpoint &lt;: Precondition</code></pre><p>Preconditioner that preconditions the linear system <span>$Ax=b$</span> with the diagonal matrix of <span>$A_c^{-1}$</span>, where <span>$A_c$</span> is the midpoint matrix of <span>$A$</span>.</p><p><strong>Notes</strong></p><ul><li><p>An object of type <code>InverseDiagonalMidpoint</code> is a function with method</p><pre><code class="nohighlight">  (idmp::InverseDiagonalMidpoint)(A::AbstractMatrix{T},
                                  b::AbstractVector{T}) where {T&lt;:Interval}</code></pre></li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [2..4 -2..1; -1..2 2..4]
2×2 Matrix{Interval{Float64}}:
  [2, 4]  [-2, 1]
 [-1, 2]   [2, 4]

julia&gt; b = [-2..2, -2..2]
2-element Vector{Interval{Float64}}:
 [-2, 2]
 [-2, 2]

julia&gt; idmp = InverseDiagonalMidpoint()
InverseDiagonalMidpoint()

julia&gt; idmp(A, b)
(Interval{Float64}[[0.666666, 1.33334] [-0.666667, 0.333334]; [-0.333334, 0.666667] [0.666666, 1.33334]], Interval{Float64}[[-0.666667, 0.666667], [-0.666667, 0.666667]])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucaferranti/IntervalLinearAlgebra.jl/blob/c107915c7acef9dfc0f76f958030b88649a102f2/src/solvers/precondition.jl#L85-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalLinearAlgebra.InverseMidpoint" href="#IntervalLinearAlgebra.InverseMidpoint"><code>IntervalLinearAlgebra.InverseMidpoint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InverseMidpoint &lt;: Precondition</code></pre><p>Preconditioner that preconditions the linear system <span>$Ax=b$</span> with <span>$A_c^{-1}$</span>, where <span>$A_c$</span> is the midpoint matrix of <span>$A$</span>.</p><p><strong>Notes</strong></p><ul><li><p>An object of type <code>NoPrecondition</code> is a function with method</p><pre><code class="nohighlight">  (imp::InverseMidpoint)(A::AbstractMatrix{T},
                         b::AbstractVector{T}) where {T&lt;:Interval}</code></pre></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [2..4 -2..1; -1..2 2..4]
2×2 Matrix{Interval{Float64}}:
  [2, 4]  [-2, 1]
 [-1, 2]   [2, 4]

julia&gt; b = [-2..2, -2..2]
2-element Vector{Interval{Float64}}:
 [-2, 2]
 [-2, 2]

julia&gt; imp = InverseMidpoint()
InverseMidpoint()

julia&gt; imp(A, b)
(Interval{Float64}[[0.594594, 1.40541] [-0.540541, 0.540541]; [-0.540541, 0.540541] [0.594594, 1.40541]], Interval{Float64}[[-0.756757, 0.756757], [-0.756757, 0.756757]])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucaferranti/IntervalLinearAlgebra.jl/blob/c107915c7acef9dfc0f76f958030b88649a102f2/src/solvers/precondition.jl#L44-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalLinearAlgebra.Jacobi" href="#IntervalLinearAlgebra.Jacobi"><code>IntervalLinearAlgebra.Jacobi</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Jacobi &lt;: AbstractIterativeSolver</code></pre><p>Type for the Jacobi solver of the interval linear system <span>$Ax=b$</span>. For details see Section 5.7.4 of <a href="../references/#[HOR19]">[HOR19]</a></p><p><strong>Fields</strong></p><ul><li><code>max_iterations</code> – maximum number of iterations (default 20)</li><li><code>atol</code>           – absolute tolerance (default 0), if at some point <span>$|xₖ - xₖ₊₁| &lt; atol$</span>                     (elementwise), then stop and return <span>$xₖ₊₁$</span>.                     If <code>atol=0</code>, then <code>min(diam(A))*1e-5</code> is used.</li></ul><p><strong>Notes</strong></p><ul><li><p>An object of type <code>Jacobi</code> is a function with method</p><pre><code class="nohighlight">  (jac::Jacobi)(A::AbstractMatrix{T},
                b::AbstractVector{T},
                [x]::AbstractVector{T}=enclose(A, b)) where {T&lt;:Interval}</code></pre><h4>Input</h4><ul><li><code>A</code>   – N×N interval matrix</li><li><code>b</code>   – interval vector of length N</li><li><code>x</code>   – (optional) initial enclosure for the solution of <span>$Ax = b$</span>. If not given,          it is automatically computed using <a href="#IntervalLinearAlgebra.enclose-Union{Tuple{T}, Tuple{N}, Tuple{StaticArrays.StaticMatrix{N, N, T}, StaticArrays.StaticVector{N, T}}} where {N, T&lt;:Interval}"><code>enclose</code></a></li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [2..4 -1..1;-1..1 2..4]
2×2 Matrix{Interval{Float64}}:
  [2, 4]  [-1, 1]
 [-1, 1]   [2, 4]

julia&gt; b = [-2..2, -1..1]
2-element Vector{Interval{Float64}}:
 [-2, 2]
 [-1, 1]

julia&gt; jac = Jacobi()
Jacobi linear solver
max_iterations = 20
atol = 0.0

julia&gt; jac(A, b)
2-element Vector{Interval{Float64}}:
 [-1.66668, 1.66668]
 [-1.33335, 1.33335]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucaferranti/IntervalLinearAlgebra.jl/blob/c107915c7acef9dfc0f76f958030b88649a102f2/src/solvers/hull.jl#L132-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalLinearAlgebra.LinearKrawczyk" href="#IntervalLinearAlgebra.LinearKrawczyk"><code>IntervalLinearAlgebra.LinearKrawczyk</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LinearKrawczyk &lt;: AbstractIterativeSolver</code></pre><p>Type for the Krawczyk solver of the interval linear system <span>$Ax=b$</span>. For details see Section 5.7.3 of <a href="../references/#[HOR19]">[HOR19]</a></p><p><strong>Fields</strong></p><ul><li><code>max_iterations</code> – maximum number of iterations (default 20)</li><li><code>atol</code>           – absolute tolerance (default 0), if at some point <span>$|xₖ - xₖ₊₁| &lt; atol$</span>                     (elementwise), then stop and return <span>$xₖ₊₁$</span>.                     If <code>atol=0</code>, then <code>min(diam(A))*1e-5</code> is used.</li></ul><p><strong>Notes</strong></p><ul><li><p>An object of type <code>LinearKrawczyk</code> is a function with method</p><pre><code class="nohighlight">  (kra::LinearKrawczyk)(A::AbstractMatrix{T},
                        b::AbstractVector{T},
                        [x]::AbstractVector{T}=enclose(A, b)) where {T&lt;:Interval}</code></pre><h4>Input</h4><ul><li><code>A</code>   – N×N interval matrix</li><li><code>b</code>   – interval vector of length N</li><li><code>x</code>   – (optional) initial enclosure for the solution of <span>$Ax = b$</span>. If not given,          it is automatically computed using <a href="#IntervalLinearAlgebra.enclose-Union{Tuple{T}, Tuple{N}, Tuple{StaticArrays.StaticMatrix{N, N, T}, StaticArrays.StaticVector{N, T}}} where {N, T&lt;:Interval}"><code>enclose</code></a></li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [2..4 -1..1;-1..1 2..4]
2×2 Matrix{Interval{Float64}}:
  [2, 4]  [-1, 1]
 [-1, 1]   [2, 4]

julia&gt; b = [-2..2, -1..1]
2-element Vector{Interval{Float64}}:
 [-2, 2]
 [-1, 1]

julia&gt; kra = LinearKrawczyk()
LinearKrawczyk linear solver
max_iterations = 20
atol = 0.0

julia&gt; kra(A, b)
2-element Vector{Interval{Float64}}:
 [-2, 2]
 [-2, 2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucaferranti/IntervalLinearAlgebra.jl/blob/c107915c7acef9dfc0f76f958030b88649a102f2/src/solvers/hull.jl#L291-L341">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalLinearAlgebra.NoPrecondition" href="#IntervalLinearAlgebra.NoPrecondition"><code>IntervalLinearAlgebra.NoPrecondition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NoPrecondition &lt;: AbstractPrecondition</code></pre><p>Type of the trivial preconditioner which does nothing.</p><p><strong>Notes</strong></p><ul><li><p>An object of type <code>NoPrecondition</code> is a function with method</p><pre><code class="nohighlight">  (np::NoPrecondition)(A::AbstractMatrix{T},
                       b::AbstractVector{T}) where {T&lt;:Interval}</code></pre></li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [2..4 -2..1; -1..2 2..4]
2×2 Matrix{Interval{Float64}}:
  [2, 4]  [-2, 1]
 [-1, 2]   [2, 4]

julia&gt; b = [-2..2, -2..2]
2-element Vector{Interval{Float64}}:
 [-2, 2]
 [-2, 2]

julia&gt; np = NoPrecondition()
NoPrecondition()

julia&gt; np(A, b)
(Interval{Float64}[[2, 4] [-2, 1]; [-1, 2] [2, 4]], Interval{Float64}[[-2, 2], [-2, 2]])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucaferranti/IntervalLinearAlgebra.jl/blob/c107915c7acef9dfc0f76f958030b88649a102f2/src/solvers/precondition.jl#L8-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalLinearAlgebra.NonLinearOettliPrager" href="#IntervalLinearAlgebra.NonLinearOettliPrager"><code>IntervalLinearAlgebra.NonLinearOettliPrager</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NonLinearOettliPrager &lt;: AbstractLinearSolver</code></pre><p>Type for the OettliPrager solver of the interval linear system <span>$Ax=b$</span>. The solver first converts the system of interval equalities into a system of real inequalities using Oettli-Präger theorem <a href="../references/#[OET64]">[OET64]</a> and then finds the feasible set using the forward-backward contractor method <a href="../references/#[JAU14]">[JAU14]</a> implemented in <code>IntervalConstraintProgramming.jl</code>.</p><p><strong>Fields</strong></p><ul><li><code>tol</code> – tolerance for the paving, default 0.01.</li></ul><p><strong>Notes</strong></p><ul><li><p>You need to import <code>IntervalConstraintProgramming.jl</code> to use this functionality.</p></li><li><p>An object of type <code>OettliPrager</code> is a function with methods</p><pre><code class="nohighlight">  (op::OettliPrager)(A::AbstractMatrix{T},
                     b::AbstractVector{T},
                     [X]::AbstractVector{T}=enclose(A, b)) where {T&lt;:Interval}

  (op::OettliPrager)(A::AbstractMatrix{T},
                     b::AbstractVector{T},
                     X::IntervalBox) where {T&lt;:Interval}</code></pre><h4>Input</h4><ul><li><code>A</code>   – N×N interval matrix</li><li><code>b</code>   – interval vector of length N</li><li><code>X</code>   – (optional) initial enclosure for the solution of <span>$Ax = b$</span>. If not given,          it is automatically computed using <a href="#IntervalLinearAlgebra.enclose-Union{Tuple{T}, Tuple{N}, Tuple{StaticArrays.StaticMatrix{N, N, T}, StaticArrays.StaticVector{N, T}}} where {N, T&lt;:Interval}"><code>enclose</code></a></li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [2..4 -2..1;-1..2 2..4]
2×2 Matrix{Interval{Float64}}:
  [2, 4]  [-2, 1]
 [-1, 2]   [2, 4]

julia&gt; b = [-2..2, -2..2]
2-element Vector{Interval{Float64}}:
 [-2, 2]
 [-2, 2]

julia&gt; op = NonLinearOettliPrager(0.1)
NonLinearOettliPrager linear solver
tol = 0.1

julia&gt; op(A, b)
Paving:
- tolerance ϵ = 0.1
- inner approx. of length 1195
- boundary approx. of length 823</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucaferranti/IntervalLinearAlgebra.jl/blob/c107915c7acef9dfc0f76f958030b88649a102f2/src/solvers/oettli.jl#L51-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalLinearAlgebra.comparison_matrix-Union{Tuple{StaticArrays.SMatrix{N, N, T, M}}, Tuple{T}, Tuple{M}, Tuple{N}} where {N, M, T&lt;:Interval}" href="#IntervalLinearAlgebra.comparison_matrix-Union{Tuple{StaticArrays.SMatrix{N, N, T, M}}, Tuple{T}, Tuple{M}, Tuple{N}} where {N, M, T&lt;:Interval}"><code>IntervalLinearAlgebra.comparison_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">comparison_matrix(A::AbstractMatrix{T}) where {T&lt;:Interval}</code></pre><p>Computes the comparison matrix <span>$⟨A⟩$</span> of the given interval matrix <span>$A$</span> according to the definition <span>$⟨A⟩ᵢᵢ = mig(Aᵢᵢ)$</span> and <span>$⟨A⟩ᵢⱼ = -mag(Aᵢⱼ)$</span> if <span>$i≠j$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [2..4 -1..1; -1..1 2..4]
2×2 Matrix{Interval{Float64}}:
  [2, 4]  [-1, 1]
 [-1, 1]   [2, 4]

julia&gt; comparison_matrix(A)
2×2 Matrix{Float64}:
  2.0  -1.0
 -1.0   2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucaferranti/IntervalLinearAlgebra.jl/blob/c107915c7acef9dfc0f76f958030b88649a102f2/src/utils.jl#L91-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalLinearAlgebra.enclose-Union{Tuple{T}, Tuple{N}, Tuple{StaticArrays.StaticMatrix{N, N, T}, StaticArrays.StaticVector{N, T}}} where {N, T&lt;:Interval}" href="#IntervalLinearAlgebra.enclose-Union{Tuple{T}, Tuple{N}, Tuple{StaticArrays.StaticMatrix{N, N, T}, StaticArrays.StaticVector{N, T}}} where {N, T&lt;:Interval}"><code>IntervalLinearAlgebra.enclose</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">enclose(A::AbstractMatrix{T}, b::AbstractVector{T}) where {T&lt;:Interval}</code></pre><p>Computes an enclosure of the solution of the interval linear system <span>$Ax=b$</span> using the algorithm described in sec. 5.7.1 of <a href="../references/#[HOR19]">[HOR19]</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucaferranti/IntervalLinearAlgebra.jl/blob/c107915c7acef9dfc0f76f958030b88649a102f2/src/utils.jl#L68-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalLinearAlgebra.interval_isapprox-Tuple{Interval, Interval}" href="#IntervalLinearAlgebra.interval_isapprox-Tuple{Interval, Interval}"><code>IntervalLinearAlgebra.interval_isapprox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">interval_isapprox(a::Interval, b::Interval; kwargs)</code></pre><p>Checks whether the intervals <span>$a$</span> and <span>$b$</span> are approximate equal, that is both their lower and upper bound are approximately equal.</p><p><strong>Keywords</strong></p><p>Same of <code>Base.isapprox</code></p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; a = 1..2
[1, 2]

julia&gt; b = a + 1e-10
[1, 2.00001]

julia&gt; interval_isapprox(a, b)
true

julia&gt; interval_isapprox(a, b; atol=1e-15)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucaferranti/IntervalLinearAlgebra.jl/blob/c107915c7acef9dfc0f76f958030b88649a102f2/src/utils.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalLinearAlgebra.interval_norm-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Interval" href="#IntervalLinearAlgebra.interval_norm-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Interval"><code>IntervalLinearAlgebra.interval_norm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">interval_norm(A::AbstractMatrix{T}) where {T&lt;:Interval}</code></pre><p>computes the infinity norm of interval matrix <span>$A$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [2..4 -1..1; -1..1 2..4]
2×2 Matrix{Interval{Float64}}:
  [2, 4]  [-1, 1]
 [-1, 1]   [2, 4]

julia&gt; interval_norm(A)
5.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucaferranti/IntervalLinearAlgebra.jl/blob/c107915c7acef9dfc0f76f958030b88649a102f2/src/utils.jl#L29-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalLinearAlgebra.interval_norm-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Interval" href="#IntervalLinearAlgebra.interval_norm-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Interval"><code>IntervalLinearAlgebra.interval_norm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">interval_norm(A::AbstractVector{T}) where {T&lt;:Interval}</code></pre><p>computes the infinity norm of interval vector <span>$v$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; b = [-2..2, -3..2]
2-element Vector{Interval{Float64}}:
 [-2, 2]
 [-3, 2]

julia&gt; interval_norm(b)
3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucaferranti/IntervalLinearAlgebra.jl/blob/c107915c7acef9dfc0f76f958030b88649a102f2/src/utils.jl#L48-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalLinearAlgebra.is_H_matrix-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Interval" href="#IntervalLinearAlgebra.is_H_matrix-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Interval"><code>IntervalLinearAlgebra.is_H_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_H_matrix(A::AbstractMatrix{T}) where {T&lt;:Interval}</code></pre><p>Tests whether the square interval matrix A is an H-matrix, by testing that <span>$⟨A⟩^{-1}e&gt;0$</span>, where <span>$e=[1, 1, …, 1]ᵀ$</span>. Note that in practice it tests that a <em>floating point approximation</em> of <span>$⟨A⟩^{-1}e$</span> satisfies the condition. For more details see section 4.4 of <a href="../references/#[HOR19]">[HOR19]</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [2..4 -1..1; -1..1 2..4]
2×2 Matrix{Interval{Float64}}:
  [2, 4]  [-1, 1]
 [-1, 1]   [2, 4]

julia&gt; is_H_matrix(A)
true

julia&gt; A = [2..4 -2..1; -1..2 2..4]
2×2 Matrix{Interval{Float64}}:
  [2, 4]  [-2, 1]
 [-1, 2]   [2, 4]

julia&gt; is_H_matrix(A)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucaferranti/IntervalLinearAlgebra.jl/blob/c107915c7acef9dfc0f76f958030b88649a102f2/src/classify.jl#L39-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalLinearAlgebra.is_M_matrix-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Interval" href="#IntervalLinearAlgebra.is_M_matrix-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Interval"><code>IntervalLinearAlgebra.is_M_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_M_matrix(A::AbstractMatrix{T}) where {T&lt;:Interval}</code></pre><p>Checks whether the square interval matrix <span>$A$</span> is an M-matrix, that is a Z-matrix with non-negative inverse. For more details see section 4.2 of <a href="../references/#[HOR19]">[HOR19]</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [2..2 -1..0; -1..0 2..2]
2×2 Matrix{Interval{Float64}}:
  [2, 2]  [-1, 0]
 [-1, 0]   [2, 2]

julia&gt; is_M_matrix(A)
true

julia&gt; A = [2..4 -2..1; -1..2 2..4]
2×2 Matrix{Interval{Float64}}:
  [2, 4]  [-2, 1]
 [-1, 2]   [2, 4]

julia&gt; is_M_matrix(A)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucaferranti/IntervalLinearAlgebra.jl/blob/c107915c7acef9dfc0f76f958030b88649a102f2/src/classify.jl#L157-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalLinearAlgebra.is_Z_matrix-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Interval" href="#IntervalLinearAlgebra.is_Z_matrix-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Interval"><code>IntervalLinearAlgebra.is_Z_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_Z_matrix(A::AbstractMatrix{T}) where {T&lt;:Interval}</code></pre><p>Checks whether the square interval matrix <span>$A$</span> is a Z-matrix, that is whether <span>$Aᵢⱼ≤0$</span> for all <span>$i≠j$</span>. For more details see section 4.2 of <a href="../references/#[HOR19]">[HOR19]</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [2..4 -2.. -1; -2.. -1 2..4]
2×2 Matrix{Interval{Float64}}:
   [2, 4]  [-2, -1]
 [-2, -1]    [2, 4]

julia&gt; is_Z_matrix(A)
true

julia&gt; A = [2..4 -2..1; -1..2 2..4]
2×2 Matrix{Interval{Float64}}:
  [2, 4]  [-2, 1]
 [-1, 2]   [2, 4]

julia&gt; is_Z_matrix(A)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucaferranti/IntervalLinearAlgebra.jl/blob/c107915c7acef9dfc0f76f958030b88649a102f2/src/classify.jl#L116-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalLinearAlgebra.is_strictly_diagonally_dominant-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Interval" href="#IntervalLinearAlgebra.is_strictly_diagonally_dominant-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Interval"><code>IntervalLinearAlgebra.is_strictly_diagonally_dominant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_strictly_diagonally_dominant(A::AbstractMatrix{T}) where {T&lt;:Interval}</code></pre><p>Checks whether the square interval matrix <span>$A$</span> of order <span>$n$</span> is stictly diagonally dominant, that is if <span>$mig(Aᵢᵢ) &gt; ∑_{k ≠ i} mag(Aᵢₖ)$</span> for <span>$i=1,…,n$</span>. For more details see section 4.5 of <a href="../references/#[HOR19]">[HOR19]</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [2..4 -1..1; -1..1 2..4]
2×2 Matrix{Interval{Float64}}:
  [2, 4]  [-1, 1]
 [-1, 1]   [2, 4]

julia&gt; is_strictly_diagonally_dominant(A)
true

julia&gt; A = [2..4 -2..1; -1..2 2..4]
2×2 Matrix{Interval{Float64}}:
  [2, 4]  [-2, 1]
 [-1, 2]   [2, 4]

julia&gt; is_strictly_diagonally_dominant(A)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucaferranti/IntervalLinearAlgebra.jl/blob/c107915c7acef9dfc0f76f958030b88649a102f2/src/classify.jl#L77-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalLinearAlgebra.is_strongly_regular-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Interval" href="#IntervalLinearAlgebra.is_strongly_regular-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Interval"><code>IntervalLinearAlgebra.is_strongly_regular</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_strongly_regular(A::AbstractMatrix{T}) where {T&lt;:Interval}</code></pre><p>Tests whether the square interval matrix <span>$A$</span> is strongly regular, i.e. if <span>$A_c^{-1}A$</span> is an H-matrix, where <span>$A_c$</span> is the midpoint matrix of <span>$A$</span>`. For more details see section 4.6 of <a href="../references/#[HOR19]">[HOR19]</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [2..4 -2..1; -1..2 2..4]
2×2 Matrix{Interval{Float64}}:
  [2, 4]  [-2, 1]
 [-1, 2]   [2, 4]

julia&gt; is_strongly_regular(A)
true

julia&gt; A = [0..2 1..1;-1.. -1 0..2]
2×2 Matrix{Interval{Float64}}:
   [0, 2]  [1, 1]
 [-1, -1]  [0, 2]

julia&gt; is_strongly_regular(A)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucaferranti/IntervalLinearAlgebra.jl/blob/c107915c7acef9dfc0f76f958030b88649a102f2/src/classify.jl#L3-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalLinearAlgebra.oettli_eq-Tuple{Any, Any, Any}" href="#IntervalLinearAlgebra.oettli_eq-Tuple{Any, Any, Any}"><code>IntervalLinearAlgebra.oettli_eq</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns the separator for the constraint <code>|a_c ⋅x - b_c| - a_r ⋅|x| - b_r &lt;= 0</code>.</p><p><code>a</code> and <code>x</code> must be vectors of the same length and <code>b</code> is scalar.</p><p>The absolue values in the equation are taken elementwise.</p><p><code>a_c</code> and <code>a_r</code> are vectors containing midpoints and radii of the intervals in <code>a</code>. Similar <code>b_c</code> and <code>b_r</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucaferranti/IntervalLinearAlgebra.jl/blob/c107915c7acef9dfc0f76f958030b88649a102f2/src/solvers/oettli.jl#L29-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalLinearAlgebra.oettli_lhs-Tuple{Any, Any, Any}" href="#IntervalLinearAlgebra.oettli_lhs-Tuple{Any, Any, Any}"><code>IntervalLinearAlgebra.oettli_lhs</code></a> — <span class="docstring-category">Method</span></header><section><div><p>returns the unrolled expression for <span>$|a ⋅x - b|$</span> <span>$a$</span> and <span>$x$</span> must be vectors of the same length and <span>$b$</span> is scalar. The absolue value in the equation is taken elementwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucaferranti/IntervalLinearAlgebra.jl/blob/c107915c7acef9dfc0f76f958030b88649a102f2/src/solvers/oettli.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalLinearAlgebra.oettli_rhs-Tuple{Any, Any, Any}" href="#IntervalLinearAlgebra.oettli_rhs-Tuple{Any, Any, Any}"><code>IntervalLinearAlgebra.oettli_rhs</code></a> — <span class="docstring-category">Method</span></header><section><div><p>returns the unrolled expression for <span>$a ⋅|x| + b$</span> <span>$a$</span> and <span>$x$</span> must be vectors of the same length and <span>$b$</span> is scalar. The absolue value in the equation is taken elementwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucaferranti/IntervalLinearAlgebra.jl/blob/c107915c7acef9dfc0f76f958030b88649a102f2/src/solvers/oettli.jl#L16-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalLinearAlgebra.rref!-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Interval" href="#IntervalLinearAlgebra.rref!-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Interval"><code>IntervalLinearAlgebra.rref!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rref!(A::AbstractMatrix{T}) where {T&lt;:Interval}</code></pre><p>In-place version of <a href="#IntervalLinearAlgebra.rref-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Interval"><code>rref</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucaferranti/IntervalLinearAlgebra.jl/blob/c107915c7acef9dfc0f76f958030b88649a102f2/src/rref.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalLinearAlgebra.rref-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Interval" href="#IntervalLinearAlgebra.rref-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Interval"><code>IntervalLinearAlgebra.rref</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rref(A::AbstractMatrix{T}) where {T&lt;:Interval}</code></pre><p>Computes the reduced row echelon form of the interval matrix <code>A</code> using maximum mignitude as pivoting strategy.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [2..4 -1..1; -1..1 2..4]
2×2 Matrix{Interval{Float64}}:
  [2, 4]  [-1, 1]
 [-1, 1]   [2, 4]

julia&gt; rref(A)
2×2 Matrix{Interval{Float64}}:
 [2, 4]  [-1, 1]
 [0, 0]       [1.5, 4.5]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucaferranti/IntervalLinearAlgebra.jl/blob/c107915c7acef9dfc0f76f958030b88649a102f2/src/rref.jl#L1-L20">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../wip/">« Explanations</a><a class="docs-footer-nextpage" href="../references/">References »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.3 on <span class="colophon-date" title="Saturday 10 July 2021 20:20">Saturday 10 July 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
